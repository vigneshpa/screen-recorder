{"version":3,"file":"js/902.js","mappings":"giBAIA,MAAMA,EAAmC,mBAAXC,QAAoD,iBAApBA,OAAOC,SACjED,OACAE,GAAe,UAAUA,KAG7B,SAASC,KAeT,MAAMC,EAXkB,oBAATC,KACAA,KAEgB,oBAAXC,OACLA,OAEgB,oBAAXC,OACLA,YADN,EAOT,SAASC,EAAaC,GAClB,MAAqB,iBAANA,GAAwB,OAANA,GAA4B,mBAANA,EAE3D,MAAMC,EAAiCP,EAEjCQ,EAAkBC,QAClBC,EAAsBD,QAAQE,UAAUC,KACxCC,EAAyBJ,QAAQK,QAAQC,KAAKP,GAC9CQ,EAAwBP,QAAQQ,OAAOF,KAAKP,GAClD,SAASU,EAAWC,GAChB,OAAO,IAAIX,EAAgBW,GAE/B,SAASC,EAAoBC,GACzB,OAAOR,EAAuBQ,GAElC,SAASC,EAAoBC,GACzB,OAAOP,EAAsBO,GAEjC,SAASC,EAAmBC,EAASC,EAAaC,GAG9C,OAAOjB,EAAoBkB,KAAKH,EAASC,EAAaC,GAE1D,SAASE,EAAYJ,EAASC,EAAaC,GACvCH,EAAmBA,EAAmBC,EAASC,EAAaC,QAAaG,EAAWvB,GAExF,SAASwB,EAAgBN,EAASC,GAC9BG,EAAYJ,EAASC,GAEzB,SAASM,EAAcP,EAASE,GAC5BE,EAAYJ,OAASK,EAAWH,GAEpC,SAASM,EAAqBR,EAASS,EAAoBC,GACvD,OAAOX,EAAmBC,EAASS,EAAoBC,GAE3D,SAASC,EAA0BX,GAC/BD,EAAmBC,OAASK,EAAWvB,GAE3C,MAAM8B,EAAiB,MACnB,MAAMC,EAAuBrC,GAAWA,EAAQoC,eAChD,GAAoC,mBAAzBC,EACP,OAAOA,EAEX,MAAMC,EAAkBnB,OAAoBU,GAC5C,OAAQU,GAAOhB,EAAmBe,EAAiBC,IANhC,GAQvB,SAASC,EAAYC,EAAGC,EAAGC,GACvB,GAAiB,mBAANF,EACP,MAAM,IAAIG,UAAU,8BAExB,OAAOC,SAASnC,UAAUoC,MAAMnB,KAAKc,EAAGC,EAAGC,GAE/C,SAASI,EAAYN,EAAGC,EAAGC,GACvB,IACI,OAAOxB,EAAoBqB,EAAYC,EAAGC,EAAGC,IAEjD,MAAOvB,GACH,OAAOC,EAAoBD,IAanC,MAAM4B,EACFC,cACIC,KAAKC,QAAU,EACfD,KAAKE,MAAQ,EAEbF,KAAKG,OAAS,CACVC,UAAW,GACXC,WAAO1B,GAEXqB,KAAKM,MAAQN,KAAKG,OAIlBH,KAAKC,QAAU,EAEfD,KAAKE,MAAQ,EAEbK,aACA,OAAOP,KAAKE,MAMhBM,KAAKC,GACD,MAAMC,EAAUV,KAAKM,MACrB,IAAIK,EAAUD,EACmBE,QAA7BF,EAAQN,UAAUG,SAClBI,EAAU,CACNP,UAAW,GACXC,WAAO1B,IAKf+B,EAAQN,UAAUI,KAAKC,GACnBE,IAAYD,IACZV,KAAKM,MAAQK,EACbD,EAAQL,MAAQM,KAElBX,KAAKE,MAIXW,QACI,MAAMC,EAAWd,KAAKG,OACtB,IAAIY,EAAWD,EACf,MAAME,EAAYhB,KAAKC,QACvB,IAAIgB,EAAYD,EAAY,EAC5B,MAAME,EAAWJ,EAASV,UACpBK,EAAUS,EAASF,GAazB,OAtEqB,QA0DjBC,IACAF,EAAWD,EAAST,MACpBY,EAAY,KAGdjB,KAAKE,MACPF,KAAKC,QAAUgB,EACXH,IAAaC,IACbf,KAAKG,OAASY,GAGlBG,EAASF,QAAarC,EACf8B,EAUXU,QAAQC,GACJ,IAAIC,EAAIrB,KAAKC,QACTqB,EAAOtB,KAAKG,OACZe,EAAWI,EAAKlB,UACpB,OAAOiB,IAAMH,EAASX,aAAyB5B,IAAf2C,EAAKjB,OAC7BgB,IAAMH,EAASX,SACfe,EAAOA,EAAKjB,MACZa,EAAWI,EAAKlB,UAChBiB,EAAI,EACoB,IAApBH,EAASX,UAIjBa,EAASF,EAASG,MAChBA,EAKVE,OACI,MAAMC,EAAQxB,KAAKG,OACbsB,EAASzB,KAAKC,QACpB,OAAOuB,EAAMpB,UAAUqB,IAI/B,SAASC,EAAsCC,EAAQC,GACnDD,EAAOE,qBAAuBD,EAC9BA,EAAOE,QAAUH,EACK,aAAlBC,EAAOG,OACPC,EAAqCL,GAEd,WAAlBC,EAAOG,OAsCpB,SAAwDJ,GACpDK,EAAqCL,GACrCM,EAAkCN,GAvC9BO,CAA+CP,GAG/CQ,EAA+CR,EAAQC,EAAOQ,cAKtE,SAASC,EAAkCV,EAAQvD,GAE/C,OAAOkE,GADQX,EAAOE,qBACczD,GAExC,SAASmE,EAAmCZ,GACG,aAAvCA,EAAOE,qBAAqBE,OAC5BS,EAAiCb,EAAQ,IAAIjC,UAAU,qFAoC/D,SAAmDiC,EAAQvD,GACvD+D,EAA+CR,EAlCO,IAAIjC,UAAU,qFAAhE+C,CAA0Cd,GAE9CA,EAAOE,qBAAqBC,aAAUnD,EACtCgD,EAAOE,0BAAuBlD,EAGlC,SAAS+D,EAAoBC,GACzB,OAAO,IAAIjD,UAAU,UAAYiD,EAAO,qCAG5C,SAASX,EAAqCL,GAC1CA,EAAOiB,eAAiB7E,GAAW,CAACJ,EAASG,KACzC6D,EAAOkB,uBAAyBlF,EAChCgE,EAAOmB,sBAAwBhF,KAGvC,SAASqE,EAA+CR,EAAQvD,GAC5D4D,EAAqCL,GACrCa,EAAiCb,EAAQvD,GAM7C,SAASoE,EAAiCb,EAAQvD,QACTO,IAAjCgD,EAAOmB,wBAGX7D,EAA0B0C,EAAOiB,gBACjCjB,EAAOmB,sBAAsB1E,GAC7BuD,EAAOkB,4BAAyBlE,EAChCgD,EAAOmB,2BAAwBnE,GAKnC,SAASsD,EAAkCN,QACDhD,IAAlCgD,EAAOkB,yBAGXlB,EAAOkB,4BAAuBlE,GAC9BgD,EAAOkB,4BAAyBlE,EAChCgD,EAAOmB,2BAAwBnE,GAGnC,MAAMoE,EAAatG,EAAe,kBAC5BuG,EAAavG,EAAe,kBAC5BwG,EAAcxG,EAAe,mBAC7ByG,EAAYzG,EAAe,iBAI3B0G,EAAiBC,OAAOC,UAAY,SAAUlG,GAChD,MAAoB,iBAANA,GAAkBkG,SAASlG,IAKvCmG,EAAYC,KAAKC,OAAS,SAAUC,GACtC,OAAOA,EAAI,EAAIF,KAAKG,KAAKD,GAAKF,KAAKI,MAAMF,IAO7C,SAASG,EAAiBC,EAAKC,GAC3B,QAAYnF,IAARkF,GAHgB,iBADF1G,EAIqB0G,IAHM,mBAAN1G,EAInC,MAAM,IAAIuC,UAAU,GAAGoE,uBAL/B,IAAsB3G,EAStB,SAAS4G,EAAe5G,EAAG2G,GACvB,GAAiB,mBAAN3G,EACP,MAAM,IAAIuC,UAAU,GAAGoE,wBAO/B,SAASE,EAAa7G,EAAG2G,GACrB,IAJJ,SAAkB3G,GACd,MAAqB,iBAANA,GAAwB,OAANA,GAA4B,mBAANA,EAGlD8G,CAAS9G,GACV,MAAM,IAAIuC,UAAU,GAAGoE,uBAG/B,SAASI,EAAuB/G,EAAGgH,EAAUL,GACzC,QAAUnF,IAANxB,EACA,MAAM,IAAIuC,UAAU,aAAayE,qBAA4BL,OAGrE,SAASM,EAAoBjH,EAAGkH,EAAOP,GACnC,QAAUnF,IAANxB,EACA,MAAM,IAAIuC,UAAU,GAAG2E,qBAAyBP,OAIxD,SAASQ,EAA0BpG,GAC/B,OAAOkF,OAAOlF,GAElB,SAASqG,EAAmBpH,GACxB,OAAa,IAANA,EAAU,EAAIA,EAMzB,SAASqH,EAAwCtG,EAAO4F,GACpD,MACMW,EAAarB,OAAOsB,iBAC1B,IAAIvH,EAAIiG,OAAOlF,GAEf,GADAf,EAAIoH,EAAmBpH,IAClBgG,EAAehG,GAChB,MAAM,IAAIuC,UAAU,GAAGoE,4BAG3B,GADA3G,EAZJ,SAAqBA,GACjB,OAAOoH,EAAmBjB,EAAUnG,IAWhCwH,CAAYxH,GACZA,EARe,GAQGA,EAAIsH,EACtB,MAAM,IAAI/E,UAAU,GAAGoE,2CAA6DW,gBAExF,OAAKtB,EAAehG,IAAY,IAANA,EAOnBA,EANI,EASf,SAASyH,EAAqBzH,EAAG2G,GAC7B,IAAKe,GAAiB1H,GAClB,MAAM,IAAIuC,UAAU,GAAGoE,8BAK/B,SAASgB,EAAmClD,GACxC,OAAO,IAAImD,EAA4BnD,GAG3C,SAASoD,EAA6BpD,EAAQqD,GAC1CrD,EAAOE,QAAQoD,cAAc1E,KAAKyE,GAEtC,SAASE,EAAiCvD,EAAQwD,EAAOC,GACrD,MACMJ,EADSrD,EAAOE,QACKoD,cAAcrE,QACrCwE,EACAJ,EAAYK,cAGZL,EAAYM,YAAYH,GAGhC,SAASI,EAAiC5D,GACtC,OAAOA,EAAOE,QAAQoD,cAAc3E,OAExC,SAASkF,EAA+B7D,GACpC,MAAMD,EAASC,EAAOE,QACtB,YAAenD,IAAXgD,KAGC+D,GAA8B/D,GAUvC,MAAMoD,EACFhF,YAAY6B,GAGR,GAFAsC,EAAuBtC,EAAQ,EAAG,+BAClCgD,EAAqBhD,EAAQ,mBACzB+D,GAAuB/D,GACvB,MAAM,IAAIlC,UAAU,+EAExBgC,EAAsC1B,KAAM4B,GAC5C5B,KAAKkF,cAAgB,IAAIpF,EAMzB8F,aACA,OAAKF,GAA8B1F,MAG5BA,KAAK4C,eAFDzE,EAAoB0H,GAAiC,WAOpEC,OAAO1H,GACH,OAAKsH,GAA8B1F,WAGDrB,IAA9BqB,KAAK6B,qBACE1D,EAAoBuE,EAAoB,WAE5CL,EAAkCrC,KAAM5B,GALpCD,EAAoB0H,GAAiC,WAYpEE,OACI,IAAKL,GAA8B1F,MAC/B,OAAO7B,EAAoB0H,GAAiC,SAEhE,QAAkClH,IAA9BqB,KAAK6B,qBACL,OAAO1D,EAAoBuE,EAAoB,cAEnD,IAAIsD,EACAC,EACJ,MAAM3H,EAAUP,GAAW,CAACJ,EAASG,KACjCkI,EAAiBrI,EACjBsI,EAAgBnI,KAQpB,OADAoI,GAAgClG,KALZ,CAChBuF,YAAaH,GAASY,EAAe,CAAE9H,MAAOkH,EAAOC,MAAM,IAC3DC,YAAa,IAAMU,EAAe,CAAE9H,WAAOS,EAAW0G,MAAM,IAC5Dc,YAAaC,GAAKH,EAAcG,KAG7B9H,EAWX+H,cACI,IAAKX,GAA8B1F,MAC/B,MAAM6F,GAAiC,eAE3C,QAAkClH,IAA9BqB,KAAK6B,qBAAT,CAGA,GAAI7B,KAAKkF,cAAc3E,OAAS,EAC5B,MAAM,IAAIb,UAAU,uFAExB6C,EAAmCvC,QAgB3C,SAAS0F,GAA8BvI,GACnC,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,kBAGtCA,aAAa4H,EAExB,SAASmB,GAAgCvE,EAAQsD,GAC7C,MAAMrD,EAASD,EAAOE,qBACtBD,EAAO4E,YAAa,EACE,WAAlB5E,EAAOG,OACPkD,EAAYK,cAEW,YAAlB1D,EAAOG,OACZkD,EAAYkB,YAAYvE,EAAOQ,cAG/BR,EAAO6E,0BAA0BvD,GAAW+B,GAIpD,SAASY,GAAiClD,GACtC,OAAO,IAAIjD,UAAU,yCAAyCiD,uDArClE2D,OAAOI,iBAAiB3B,EAA4BvH,UAAW,CAC3DsI,OAAQ,CAAEa,YAAY,GACtBZ,KAAM,CAAEY,YAAY,GACpBN,YAAa,CAAEM,YAAY,GAC3Bf,OAAQ,CAAEe,YAAY,KAEgB,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAe9B,EAA4BvH,UAAWf,EAAemK,YAAa,CACrF1I,MAAO,8BACP4I,cAAc,IAiCtB,MAAMC,GAAyBT,OAAOU,eAAeV,OAAOU,gBAAeC,sBAAwBzJ,WAGnG,MAAM0J,GACFnH,YAAY4B,EAAQwF,GAChBnH,KAAKoH,qBAAkBzI,EACvBqB,KAAKqH,aAAc,EACnBrH,KAAK8B,QAAUH,EACf3B,KAAKsH,eAAiBH,EAE1BI,OACI,MAAMC,EAAY,IAAMxH,KAAKyH,aAI7B,OAHAzH,KAAKoH,gBAAkBpH,KAAKoH,gBACxBtI,EAAqBkB,KAAKoH,gBAAiBI,EAAWA,GACtDA,IACGxH,KAAKoH,gBAEhBM,OAAOxJ,GACH,MAAMyJ,EAAc,IAAM3H,KAAK4H,aAAa1J,GAC5C,OAAO8B,KAAKoH,gBACRtI,EAAqBkB,KAAKoH,gBAAiBO,EAAaA,GACxDA,IAERF,aACI,GAAIzH,KAAKqH,YACL,OAAO/J,QAAQK,QAAQ,CAAEO,WAAOS,EAAW0G,MAAM,IAErD,MAAM1D,EAAS3B,KAAK8B,QACpB,QAAoCnD,IAAhCgD,EAAOE,qBACP,OAAO1D,EAAoBuE,EAAoB,YAEnD,IAAIsD,EACAC,EACJ,MAAM3H,EAAUP,GAAW,CAACJ,EAASG,KACjCkI,EAAiBrI,EACjBsI,EAAgBnI,KAuBpB,OADAoI,GAAgCvE,EApBZ,CAChB4D,YAAaH,IACTpF,KAAKoH,qBAAkBzI,EAGvBO,GAAe,IAAM8G,EAAe,CAAE9H,MAAOkH,EAAOC,MAAM,OAE9DC,YAAa,KACTtF,KAAKoH,qBAAkBzI,EACvBqB,KAAKqH,aAAc,EACnB9E,EAAmCZ,GACnCqE,EAAe,CAAE9H,WAAOS,EAAW0G,MAAM,KAE7Cc,YAAa/H,IACT4B,KAAKoH,qBAAkBzI,EACvBqB,KAAKqH,aAAc,EACnB9E,EAAmCZ,GACnCsE,EAAc7H,MAIfE,EAEXsJ,aAAa1J,GACT,GAAI8B,KAAKqH,YACL,OAAO/J,QAAQK,QAAQ,CAAEO,MAAAA,EAAOmH,MAAM,IAE1CrF,KAAKqH,aAAc,EACnB,MAAM1F,EAAS3B,KAAK8B,QACpB,QAAoCnD,IAAhCgD,EAAOE,qBACP,OAAO1D,EAAoBuE,EAAoB,qBAEnD,IAAK1C,KAAKsH,eAAgB,CACtB,MAAMO,EAASxF,EAAkCV,EAAQzD,GAEzD,OADAqE,EAAmCZ,GAC5B7C,EAAqB+I,GAAQ,KAAM,CAAG3J,MAAAA,EAAOmH,MAAM,MAG9D,OADA9C,EAAmCZ,GAC5B1D,EAAoB,CAAEC,MAAAA,EAAOmH,MAAM,KAGlD,MAAMyC,GAAuC,CACzCP,OACI,OAAKQ,GAA8B/H,MAG5BA,KAAKgI,mBAAmBT,OAFpBpJ,EAAoB8J,GAAuC,UAI1EP,OAAOxJ,GACH,OAAK6J,GAA8B/H,MAG5BA,KAAKgI,mBAAmBN,OAAOxJ,GAF3BC,EAAoB8J,GAAuC,aAgB9E,SAASF,GAA8B5K,GACnC,IAAKD,EAAaC,GACd,OAAO,EAEX,IAAKmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,sBACzC,OAAO,EAEX,IAEI,OAAOA,EAAE6K,8BACLd,GAER,MAAOgB,GACH,OAAO,GAIf,SAASD,GAAuCtF,GAC5C,OAAO,IAAIjD,UAAU,+BAA+BiD,2DA7BzBhE,IAA3BoI,IACAT,OAAO6B,eAAeL,GAAsCf,IAiChE,MAAMqB,GAAchF,OAAOiF,OAAS,SAAUlL,GAE1C,OAAOA,GAAMA,GAGjB,SAASmL,GAAoBpH,GAGzB,OAAOA,EAASqH,QAEpB,SAASC,GAAmBC,EAAMC,EAAYC,EAAKC,EAAWC,GAC1D,IAAIC,WAAWL,GAAMM,IAAI,IAAID,WAAWH,EAAKC,EAAWC,GAAIH,GAWhE,SAASM,GAAiBC,EAAQC,EAAOC,GAGrC,GAAIF,EAAOV,MACP,OAAOU,EAAOV,MAAMW,EAAOC,GAE/B,MAAM5I,EAAS4I,EAAMD,EACfX,EAAQ,IAAIa,YAAY7I,GAE9B,OADAiI,GAAmBD,EAAO,EAAGU,EAAQC,EAAO3I,GACrCgI,EAeX,SAASc,GAAkBC,GACvB,MAAML,EAASD,GAAiBM,EAAEL,OAAQK,EAAEC,WAAYD,EAAEC,WAAaD,EAAEE,YACzE,OAAO,IAAIV,WAAWG,GAG1B,SAASQ,GAAaC,GAClB,MAAMC,EAAOD,EAAUE,OAAO/I,QAK9B,OAJA6I,EAAUG,iBAAmBF,EAAKG,KAC9BJ,EAAUG,gBAAkB,IAC5BH,EAAUG,gBAAkB,GAEzBF,EAAKzL,MAEhB,SAAS6L,GAAqBL,EAAWxL,EAAO4L,GAC5C,GAzBiB,iBADQrG,EA0BAqG,IAtBrB1B,GAAY3E,IAGZA,EAAI,GAmB0BqG,IAASE,EAAAA,EACvC,MAAM,IAAIC,WAAW,wDA3B7B,IAA6BxG,EA6BzBiG,EAAUE,OAAOpJ,KAAK,CAAEtC,MAAAA,EAAO4L,KAAAA,IAC/BJ,EAAUG,iBAAmBC,EAMjC,SAASI,GAAWR,GAChBA,EAAUE,OAAS,IAAI9J,EACvB4J,EAAUG,gBAAkB,EAQhC,MAAMM,GACFpK,cACI,MAAM,IAAIL,UAAU,uBAKpB0K,WACA,IAAKC,GAA4BrK,MAC7B,MAAMsK,GAA+B,QAEzC,OAAOtK,KAAKuK,MAEhBC,QAAQC,GACJ,IAAKJ,GAA4BrK,MAC7B,MAAMsK,GAA+B,WAIzC,GAFApG,EAAuBuG,EAAc,EAAG,WACxCA,EAAejG,EAAwCiG,EAAc,wBAChB9L,IAAjDqB,KAAK0K,wCACL,MAAM,IAAIhL,UAAU,0CAEHM,KAAKuK,MAAMtB,OAChC0B,GAAoC3K,KAAK0K,wCAAyCD,GAEtFG,mBAAmBR,GACf,IAAKC,GAA4BrK,MAC7B,MAAMsK,GAA+B,sBAGzC,GADApG,EAAuBkG,EAAM,EAAG,uBAC3BhB,YAAYyB,OAAOT,GACpB,MAAM,IAAI1K,UAAU,gDAExB,QAAqDf,IAAjDqB,KAAK0K,wCACL,MAAM,IAAIhL,UAAU,0CAEH0K,EAAKnB,OAC1B6B,GAA+C9K,KAAK0K,wCAAyCN,IAGrG9D,OAAOI,iBAAiByD,GAA0B3M,UAAW,CACzDgN,QAAS,CAAE7D,YAAY,GACvBiE,mBAAoB,CAAEjE,YAAY,GAClCyD,KAAM,CAAEzD,YAAY,KAEkB,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAesD,GAA0B3M,UAAWf,EAAemK,YAAa,CACnF1I,MAAO,4BACP4I,cAAc,IAQtB,MAAMiE,GACFhL,cACI,MAAM,IAAIL,UAAU,uBAKpBsL,kBACA,IAAKC,GAA+BjL,MAChC,MAAMkL,GAAwC,eAElD,OAAOC,GAA2CnL,MAMlDoL,kBACA,IAAKH,GAA+BjL,MAChC,MAAMkL,GAAwC,eAElD,OAAOG,GAA2CrL,MAMtDsL,QACI,IAAKL,GAA+BjL,MAChC,MAAMkL,GAAwC,SAElD,GAAIlL,KAAKuL,gBACL,MAAM,IAAI7L,UAAU,8DAExB,MAAM8L,EAAQxL,KAAKyL,8BAA8B1J,OACjD,GAAc,aAAVyJ,EACA,MAAM,IAAI9L,UAAU,kBAAkB8L,8DAE1CE,GAAkC1L,MAEtC2L,QAAQvG,GACJ,IAAK6F,GAA+BjL,MAChC,MAAMkL,GAAwC,WAGlD,GADAhH,EAAuBkB,EAAO,EAAG,YAC5BgE,YAAYyB,OAAOzF,GACpB,MAAM,IAAI1F,UAAU,sCAExB,GAAyB,IAArB0F,EAAMoE,WACN,MAAM,IAAI9J,UAAU,uCAExB,GAAgC,IAA5B0F,EAAM6D,OAAOO,WACb,MAAM,IAAI9J,UAAU,gDAExB,GAAIM,KAAKuL,gBACL,MAAM,IAAI7L,UAAU,gCAExB,MAAM8L,EAAQxL,KAAKyL,8BAA8B1J,OACjD,GAAc,aAAVyJ,EACA,MAAM,IAAI9L,UAAU,kBAAkB8L,mEAE1CI,GAAoC5L,KAAMoF,GAK9CyG,MAAMzF,GACF,IAAK6E,GAA+BjL,MAChC,MAAMkL,GAAwC,SAElDY,GAAkC9L,KAAMoG,GAG5C,CAACnD,GAAa7E,GACV2N,GAAkD/L,MAClDkK,GAAWlK,MACX,MAAM6H,EAAS7H,KAAKgM,iBAAiB5N,GAErC,OADA6N,GAA4CjM,MACrC6H,EAGX,CAAC3E,GAAW+B,GACR,MAAMrD,EAAS5B,KAAKyL,8BACpB,GAAIzL,KAAK6J,gBAAkB,EAAG,CAC1B,MAAMqC,EAAQlM,KAAK4J,OAAO/I,QAC1Bb,KAAK6J,iBAAmBqC,EAAM1C,WAC9B2C,GAA6CnM,MAC7C,MAAMoK,EAAO,IAAItB,WAAWoD,EAAMjD,OAAQiD,EAAM3C,WAAY2C,EAAM1C,YAElE,YADAvE,EAAYM,YAAY6E,GAG5B,MAAMgC,EAAwBpM,KAAKqM,uBACnC,QAA8B1N,IAA1ByN,EAAqC,CACrC,IAAInD,EACJ,IACIA,EAAS,IAAIG,YAAYgD,GAE7B,MAAOE,GAEH,YADArH,EAAYkB,YAAYmG,GAG5B,MAAMC,EAAqB,CACvBtD,OAAAA,EACAuD,iBAAkBJ,EAClB7C,WAAY,EACZC,WAAY4C,EACZK,YAAa,EACbC,YAAa,EACbC,gBAAiB7D,WACjB8D,WAAY,WAEhB5M,KAAK6M,kBAAkBrM,KAAK+L,GAEhCvH,EAA6BpD,EAAQqD,GACrC6H,GAA6C9M,OAiBrD,SAASiL,GAA+B9N,GACpC,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,kCAGtCA,aAAa4N,GAExB,SAASV,GAA4BlN,GACjC,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,4CAGtCA,aAAagN,GAExB,SAAS2C,GAA6CC,GAClD,MAAMC,EA6MV,SAAoDD,GAChD,MAAMnL,EAASmL,EAAWtB,8BAC1B,MAAsB,aAAlB7J,EAAOG,UAGPgL,EAAWxB,oBAGVwB,EAAWE,cAGZxH,EAA+B7D,IAAW4D,EAAiC5D,GAAU,QAGrFsL,GAA4BtL,IAAWuL,GAAqCvL,GAAU,IAGtEyJ,GAA2C0B,GAC7C,MA/NCK,CAA2CL,GACzDC,IAGDD,EAAWM,SACXN,EAAWO,YAAa,GAG5BP,EAAWM,UAAW,EAGtB3O,EADoBqO,EAAWQ,kBACN,KACrBR,EAAWM,UAAW,EAClBN,EAAWO,aACXP,EAAWO,YAAa,EACxBR,GAA6CC,OAElD3G,IACC0F,GAAkCiB,EAAY3G,QAGtD,SAAS2F,GAAkDgB,GACvDS,GAAkDT,GAClDA,EAAWF,kBAAoB,IAAI/M,EAEvC,SAAS2N,GAAqD7L,EAAQ2K,GAClE,IAAIlH,GAAO,EACW,WAAlBzD,EAAOG,SACPsD,GAAO,GAEX,MAAMqI,EAAaC,GAAsDpB,GACnC,YAAlCA,EAAmBK,WACnBzH,EAAiCvD,EAAQ8L,EAAYrI,GA8Y7D,SAA8CzD,EAAQwD,EAAOC,GACzD,MACMuI,EADShM,EAAOE,QACS+L,kBAAkBhN,QAC7CwE,EACAuI,EAAgBtI,YAAYF,GAG5BwI,EAAgBrI,YAAYH,GAlZ5B0I,CAAqClM,EAAQ8L,EAAYrI,GAGjE,SAASsI,GAAsDpB,GAC3D,MAAME,EAAcF,EAAmBE,YACjCC,EAAcH,EAAmBG,YACvC,OAAO,IAAIH,EAAmBI,gBAAgBJ,EAAmBtD,OAAQsD,EAAmBhD,WAAYkD,EAAcC,GAE1H,SAASqB,GAAgDhB,EAAY9D,EAAQM,EAAYC,GACrFuD,EAAWnD,OAAOpJ,KAAK,CAAEyI,OAAAA,EAAQM,WAAAA,EAAYC,WAAAA,IAC7CuD,EAAWlD,iBAAmBL,EAElC,SAASwE,GAA4DjB,EAAYR,GAC7E,MAAMG,EAAcH,EAAmBG,YACjCuB,EAAsB1B,EAAmBE,YAAcF,EAAmBE,YAAcC,EACxFwB,EAAiB3K,KAAK4K,IAAIpB,EAAWlD,gBAAiB0C,EAAmB/C,WAAa+C,EAAmBE,aACzG2B,EAAiB7B,EAAmBE,YAAcyB,EAClDG,EAAkBD,EAAiBA,EAAiB1B,EAC1D,IAAI4B,EAA4BJ,EAC5BK,GAAQ,EACRF,EAAkBJ,IAClBK,EAA4BD,EAAkB9B,EAAmBE,YACjE8B,GAAQ,GAEZ,MAAMC,EAAQzB,EAAWnD,OACzB,KAAO0E,EAA4B,GAAG,CAClC,MAAMG,EAAcD,EAAMjN,OACpBmN,EAAcnL,KAAK4K,IAAIG,EAA2BG,EAAYjF,YAC9DmF,EAAYpC,EAAmBhD,WAAagD,EAAmBE,YACrEjE,GAAmB+D,EAAmBtD,OAAQ0F,EAAWF,EAAYxF,OAAQwF,EAAYlF,WAAYmF,GACjGD,EAAYjF,aAAekF,EAC3BF,EAAM3N,SAGN4N,EAAYlF,YAAcmF,EAC1BD,EAAYjF,YAAckF,GAE9B3B,EAAWlD,iBAAmB6E,EAC9BE,GAAuD7B,EAAY2B,EAAanC,GAChF+B,GAA6BI,EAEjC,OAAOH,EAEX,SAASK,GAAuD7B,EAAYjD,EAAMyC,GAC9EA,EAAmBE,aAAe3C,EAEtC,SAASqC,GAA6CY,GACf,IAA/BA,EAAWlD,iBAAyBkD,EAAWxB,iBAC/CU,GAA4Cc,GAC5C8B,GAAoB9B,EAAWtB,gCAG/BqB,GAA6CC,GAGrD,SAASS,GAAkDT,GACvB,OAA5BA,EAAW+B,eAGf/B,EAAW+B,aAAapE,6CAA0C/L,EAClEoO,EAAW+B,aAAavE,MAAQ,KAChCwC,EAAW+B,aAAe,MAE9B,SAASC,GAAiEhC,GACtE,KAAOA,EAAWF,kBAAkBtM,OAAS,GAAG,CAC5C,GAAmC,IAA/BwM,EAAWlD,gBACX,OAEJ,MAAM0C,EAAqBQ,EAAWF,kBAAkBtL,OACpDyM,GAA4DjB,EAAYR,KACxEyC,GAAiDjC,GACjDU,GAAqDV,EAAWtB,8BAA+Bc,KAmF3G,SAAS0C,GAA4ClC,EAAYtC,GAC7D,MAAMyE,EAAkBnC,EAAWF,kBAAkBtL,OACrDiM,GAAkDT,GAEpC,WADAA,EAAWtB,8BAA8B1J,OA5B3D,SAA0DgL,EAAYmC,GAClE,MAAMtN,EAASmL,EAAWtB,8BAC1B,GAAIyB,GAA4BtL,GAC5B,KAAOuL,GAAqCvL,GAAU,GAElD6L,GAAqD7L,EAD1BoN,GAAiDjC,IA0BhFoC,CAAiDpC,GArBzD,SAA4DA,EAAYtC,EAAc8B,GAElF,GADAqC,GAAuD7B,EAAYtC,EAAc8B,GAC7EA,EAAmBE,YAAcF,EAAmBG,YACpD,OAEJsC,GAAiDjC,GACjD,MAAMqC,EAAgB7C,EAAmBE,YAAcF,EAAmBG,YAC1E,GAAI0C,EAAgB,EAAG,CACnB,MAAMjG,EAAMoD,EAAmBhD,WAAagD,EAAmBE,YACzD4C,EAAYrG,GAAiBuD,EAAmBtD,OAAQE,EAAMiG,EAAejG,GACnF4E,GAAgDhB,EAAYsC,EAAW,EAAGA,EAAU7F,YAExF+C,EAAmBE,aAAe2C,EAClC3B,GAAqDV,EAAWtB,8BAA+Bc,GAC/FwC,GAAiEhC,GAU7DuC,CAAmDvC,EAAYtC,EAAcyE,GAEjFpC,GAA6CC,GAEjD,SAASiC,GAAiDjC,GAEtD,OADmBA,EAAWF,kBAAkBhM,QA0BpD,SAASoL,GAA4Cc,GACjDA,EAAWQ,oBAAiB5O,EAC5BoO,EAAWf,sBAAmBrN,EAGlC,SAAS+M,GAAkCqB,GACvC,MAAMnL,EAASmL,EAAWtB,8BAC1B,IAAIsB,EAAWxB,iBAAqC,aAAlB3J,EAAOG,OAGzC,GAAIgL,EAAWlD,gBAAkB,EAC7BkD,EAAWxB,iBAAkB,MADjC,CAIA,GAAIwB,EAAWF,kBAAkBtM,OAAS,GACTwM,EAAWF,kBAAkBtL,OACjCkL,YAAc,EAAG,CACtC,MAAMrG,EAAI,IAAI1G,UAAU,2DAExB,MADAoM,GAAkCiB,EAAY3G,GACxCA,EAGd6F,GAA4Cc,GAC5C8B,GAAoBjN,IAExB,SAASgK,GAAoCmB,EAAY3H,GACrD,MAAMxD,EAASmL,EAAWtB,8BAC1B,GAAIsB,EAAWxB,iBAAqC,aAAlB3J,EAAOG,OACrC,OAEJ,MAAMkH,EAAS7D,EAAM6D,OACfM,EAAanE,EAAMmE,WACnBC,EAAapE,EAAMoE,WACnB+F,EAAwCtG,EAC9C,GAAI8D,EAAWF,kBAAkBtM,OAAS,EAAG,CACzC,MAAMiP,EAAuBzC,EAAWF,kBAAkBtL,OACrCiO,EAAqBvG,OAC1CuG,EAAqBvG,OAA6BuG,EAAqBvG,OAE3EuE,GAAkDT,GAC9CtH,EAA+B7D,GACkB,IAA7C4D,EAAiC5D,GACjCmM,GAAgDhB,EAAYwC,EAAmBhG,EAAYC,IAGvFuD,EAAWF,kBAAkBtM,OAAS,GACtCyO,GAAiDjC,GAGrD5H,EAAiCvD,EADT,IAAIkH,WAAWyG,EAAmBhG,EAAYC,IACZ,IAGzD0D,GAA4BtL,IAEjCmM,GAAgDhB,EAAYwC,EAAmBhG,EAAYC,GAC3FuF,GAAiEhC,IAGjEgB,GAAgDhB,EAAYwC,EAAmBhG,EAAYC,GAE/FsD,GAA6CC,GAEjD,SAASjB,GAAkCiB,EAAY3G,GACnD,MAAMxE,EAASmL,EAAWtB,8BACJ,aAAlB7J,EAAOG,SAGXgK,GAAkDgB,GAClD7C,GAAW6C,GACXd,GAA4Cc,GAC5C0C,GAAoB7N,EAAQwE,IAEhC,SAAS+E,GAA2C4B,GAChD,GAAgC,OAA5BA,EAAW+B,cAAyB/B,EAAWF,kBAAkBtM,OAAS,EAAG,CAC7E,MAAM2O,EAAkBnC,EAAWF,kBAAkBtL,OAC/C6I,EAAO,IAAItB,WAAWoG,EAAgBjG,OAAQiG,EAAgB3F,WAAa2F,EAAgBzC,YAAayC,EAAgB1F,WAAa0F,EAAgBzC,aACrJzB,EAAc1E,OAAOoJ,OAAOvF,GAA0B3M,YAyGpE,SAAwCmS,EAAS5C,EAAY3C,GACzDuF,EAAQjF,wCAA0CqC,EAClD4C,EAAQpF,MAAQH,EA1GZwF,CAA+B5E,EAAa+B,EAAY3C,GACxD2C,EAAW+B,aAAe9D,EAE9B,OAAO+B,EAAW+B,aAEtB,SAASzD,GAA2C0B,GAChD,MAAMvB,EAAQuB,EAAWtB,8BAA8B1J,OACvD,MAAc,YAAVyJ,EACO,KAEG,WAAVA,EACO,EAEJuB,EAAW8C,aAAe9C,EAAWlD,gBAEhD,SAASc,GAAoCoC,EAAYtC,GACrD,MAAMyE,EAAkBnC,EAAWF,kBAAkBtL,OAErD,GAAc,WADAwL,EAAWtB,8BAA8B1J,QAEnD,GAAqB,IAAjB0I,EACA,MAAM,IAAI/K,UAAU,wEAGvB,CACD,GAAqB,IAAjB+K,EACA,MAAM,IAAI/K,UAAU,mFAExB,GAAIwP,EAAgBzC,YAAchC,EAAeyE,EAAgB1F,WAC7D,MAAM,IAAIS,WAAW,6BAG7BiF,EAAgBjG,OAA6BiG,EAAgBjG,OAC7DgG,GAA4ClC,EAAYtC,GAE5D,SAASK,GAA+CiC,EAAY3C,GAChE,MAAM8E,EAAkBnC,EAAWF,kBAAkBtL,OAErD,GAAc,WADAwL,EAAWtB,8BAA8B1J,QAEnD,GAAwB,IAApBqI,EAAKZ,WACL,MAAM,IAAI9J,UAAU,yFAIxB,GAAwB,IAApB0K,EAAKZ,WACL,MAAM,IAAI9J,UAAU,mGAG5B,GAAIwP,EAAgB3F,WAAa2F,EAAgBzC,cAAgBrC,EAAKb,WAClE,MAAM,IAAIU,WAAW,2DAEzB,GAAIiF,EAAgB1C,mBAAqBpC,EAAKnB,OAAOO,WACjD,MAAM,IAAIS,WAAW,8DAEzB,GAAIiF,EAAgBzC,YAAcrC,EAAKZ,WAAa0F,EAAgB1F,WAChE,MAAM,IAAIS,WAAW,2DAEzB,MAAM6F,EAAiB1F,EAAKZ,WAC5B0F,EAAgBjG,OAA6BmB,EAAKnB,OAClDgG,GAA4ClC,EAAY+C,GAE5D,SAASC,GAAkCnO,EAAQmL,EAAYiD,EAAgBC,EAAeC,EAAiBC,EAAe/D,GAC1HW,EAAWtB,8BAAgC7J,EAC3CmL,EAAWO,YAAa,EACxBP,EAAWM,UAAW,EACtBN,EAAW+B,aAAe,KAE1B/B,EAAWnD,OAASmD,EAAWlD,qBAAkBlL,EACjDuL,GAAW6C,GACXA,EAAWxB,iBAAkB,EAC7BwB,EAAWE,UAAW,EACtBF,EAAW8C,aAAeM,EAC1BpD,EAAWQ,eAAiB0C,EAC5BlD,EAAWf,iBAAmBkE,EAC9BnD,EAAWV,uBAAyBD,EACpCW,EAAWF,kBAAoB,IAAI/M,EACnC8B,EAAO6E,0BAA4BsG,EAEnCrO,EAAYT,EADQ+R,MAC0B,KAC1CjD,EAAWE,UAAW,EACtBH,GAA6CC,MAC9CqD,IACCtE,GAAkCiB,EAAYqD,MA4BtD,SAAS9F,GAA+B3H,GACpC,OAAO,IAAIjD,UAAU,uCAAuCiD,qDAGhE,SAASuI,GAAwCvI,GAC7C,OAAO,IAAIjD,UAAU,0CAA0CiD,wDAInE,SAAS0N,GAAgCzO,GACrC,OAAO,IAAI0O,GAAyB1O,GAGxC,SAAS2O,GAAiC3O,EAAQgM,GAC9ChM,EAAOE,QAAQ+L,kBAAkBrN,KAAKoN,GAY1C,SAAST,GAAqCvL,GAC1C,OAAOA,EAAOE,QAAQ+L,kBAAkBtN,OAE5C,SAAS2M,GAA4BtL,GACjC,MAAMD,EAASC,EAAOE,QACtB,YAAenD,IAAXgD,KAGC6O,GAA2B7O,GAjepC2E,OAAOI,iBAAiBqE,GAA6BvN,UAAW,CAC5D8N,MAAO,CAAE3E,YAAY,GACrBgF,QAAS,CAAEhF,YAAY,GACvBkF,MAAO,CAAElF,YAAY,GACrBqE,YAAa,CAAErE,YAAY,GAC3ByE,YAAa,CAAEzE,YAAY,KAEW,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAekE,GAA6BvN,UAAWf,EAAemK,YAAa,CACtF1I,MAAO,+BACP4I,cAAc,IAietB,MAAMwJ,GACFvQ,YAAY6B,GAGR,GAFAsC,EAAuBtC,EAAQ,EAAG,4BAClCgD,EAAqBhD,EAAQ,mBACzB+D,GAAuB/D,GACvB,MAAM,IAAIlC,UAAU,+EAExB,IAAKuL,GAA+BrJ,EAAO6E,2BACvC,MAAM,IAAI/G,UAAU,+FAGxBgC,EAAsC1B,KAAM4B,GAC5C5B,KAAK6N,kBAAoB,IAAI/N,EAM7B8F,aACA,OAAK4K,GAA2BxQ,MAGzBA,KAAK4C,eAFDzE,EAAoBsS,GAA8B,WAOjE3K,OAAO1H,GACH,OAAKoS,GAA2BxQ,WAGErB,IAA9BqB,KAAK6B,qBACE1D,EAAoBuE,EAAoB,WAE5CL,EAAkCrC,KAAM5B,GALpCD,EAAoBsS,GAA8B,WAYjE1K,KAAKqE,GACD,IAAKoG,GAA2BxQ,MAC5B,OAAO7B,EAAoBsS,GAA8B,SAE7D,IAAKrH,YAAYyB,OAAOT,GACpB,OAAOjM,EAAoB,IAAIuB,UAAU,sCAE7C,GAAwB,IAApB0K,EAAKZ,WACL,OAAOrL,EAAoB,IAAIuB,UAAU,uCAE7C,GAA+B,IAA3B0K,EAAKnB,OAAOO,WACZ,OAAOrL,EAAoB,IAAIuB,UAAU,gDAG7C,GADqB0K,EAAKnB,YACQtK,IAA9BqB,KAAK6B,qBACL,OAAO1D,EAAoBuE,EAAoB,cAEnD,IAAIsD,EACAC,EACJ,MAAM3H,EAAUP,GAAW,CAACJ,EAASG,KACjCkI,EAAiBrI,EACjBsI,EAAgBnI,KAQpB,OADA4S,GAA6B1Q,KAAMoK,EALX,CACpB7E,YAAaH,GAASY,EAAe,CAAE9H,MAAOkH,EAAOC,MAAM,IAC3DC,YAAaF,GAASY,EAAe,CAAE9H,MAAOkH,EAAOC,MAAM,IAC3Dc,YAAaC,GAAKH,EAAcG,KAG7B9H,EAWX+H,cACI,IAAKmK,GAA2BxQ,MAC5B,MAAMyQ,GAA8B,eAExC,QAAkC9R,IAA9BqB,KAAK6B,qBAAT,CAGA,GAAI7B,KAAK6N,kBAAkBtN,OAAS,EAChC,MAAM,IAAIb,UAAU,uFAExB6C,EAAmCvC,QAgB3C,SAASwQ,GAA2BrT,GAChC,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,sBAGtCA,aAAamT,GAExB,SAASI,GAA6B/O,EAAQyI,EAAMwD,GAChD,MAAMhM,EAASD,EAAOE,qBACtBD,EAAO4E,YAAa,EACE,YAAlB5E,EAAOG,OACP6L,EAAgBzH,YAAYvE,EAAOQ,cApd3C,SAA8C2K,EAAY3C,EAAMwD,GAC5D,MAAMhM,EAASmL,EAAWtB,8BAC1B,IAAIiB,EAAc,EACdtC,EAAKrK,cAAgB4Q,WACrBjE,EAActC,EAAKrK,YAAY6Q,mBAEnC,MAAMC,EAAOzG,EAAKrK,YAEZkJ,EAA6BmB,EAAKnB,OAKlCsD,EAAqB,CACvBtD,OAAAA,EACAuD,iBAAkBvD,EAAOO,WACzBD,WAAYa,EAAKb,WACjBC,WAAYY,EAAKZ,WACjBiD,YAAa,EACbC,YAAAA,EACAC,gBAAiBkE,EACjBjE,WAAY,QAEhB,GAAIG,EAAWF,kBAAkBtM,OAAS,EAMtC,OALAwM,EAAWF,kBAAkBrM,KAAK+L,QAIlCgE,GAAiC3O,EAAQgM,GAG7C,GAAsB,WAAlBhM,EAAOG,OAAX,CAKA,GAAIgL,EAAWlD,gBAAkB,EAAG,CAChC,GAAImE,GAA4DjB,EAAYR,GAAqB,CAC7F,MAAMmB,EAAaC,GAAsDpB,GAGzE,OAFAJ,GAA6CY,QAC7Ca,EAAgBrI,YAAYmI,GAGhC,GAAIX,EAAWxB,gBAAiB,CAC5B,MAAMnF,EAAI,IAAI1G,UAAU,2DAGxB,OAFAoM,GAAkCiB,EAAY3G,QAC9CwH,EAAgBzH,YAAYC,IAIpC2G,EAAWF,kBAAkBrM,KAAK+L,GAClCgE,GAAiC3O,EAAQgM,GACzCd,GAA6CC,OArB7C,CACI,MAAM+D,EAAY,IAAID,EAAKtE,EAAmBtD,OAAQsD,EAAmBhD,WAAY,GACrFqE,EAAgBtI,YAAYwL,IAsb5BC,CAAqCnP,EAAO6E,0BAA2B2D,EAAMwD,GAIrF,SAAS6C,GAA8B9N,GACnC,OAAO,IAAIjD,UAAU,sCAAsCiD,oDAG/D,SAASqO,GAAqBC,EAAUC,GACpC,MAAM,cAAEf,GAAkBc,EAC1B,QAAsBtS,IAAlBwR,EACA,OAAOe,EAEX,GAAI9I,GAAY+H,IAAkBA,EAAgB,EAC9C,MAAM,IAAIlG,WAAW,yBAEzB,OAAOkG,EAEX,SAASgB,GAAqBF,GAC1B,MAAM,KAAEnH,GAASmH,EACjB,OAAKnH,GACM,KAAM,GAKrB,SAASsH,GAAuBC,EAAMvN,GAClCF,EAAiByN,EAAMvN,GACvB,MAAMqM,EAAgBkB,MAAAA,OAAmC,EAASA,EAAKlB,cACjErG,EAAOuH,MAAAA,OAAmC,EAASA,EAAKvH,KAC9D,MAAO,CACHqG,mBAAiCxR,IAAlBwR,OAA8BxR,EAAY2F,EAA0B6L,GACnFrG,UAAenL,IAATmL,OAAqBnL,EAAY2S,GAA2BxH,EAAM,GAAGhG,6BAGnF,SAASwN,GAA2BjS,EAAIyE,GAEpC,OADAC,EAAe1E,EAAIyE,GACZsB,GAASd,EAA0BjF,EAAG+F,IA0BjD,SAASmM,GAAmClS,EAAImS,EAAU1N,GAEtD,OADAC,EAAe1E,EAAIyE,GACX1F,GAAWyB,EAAYR,EAAImS,EAAU,CAACpT,IAElD,SAASqT,GAAmCpS,EAAImS,EAAU1N,GAEtD,OADAC,EAAe1E,EAAIyE,GACZ,IAAMjE,EAAYR,EAAImS,EAAU,IAE3C,SAASE,GAAmCrS,EAAImS,EAAU1N,GAEtD,OADAC,EAAe1E,EAAIyE,GACXiJ,GAAezN,EAAYD,EAAImS,EAAU,CAACzE,IAEtD,SAAS4E,GAAmCtS,EAAImS,EAAU1N,GAEtD,OADAC,EAAe1E,EAAIyE,GACZ,CAACsB,EAAO2H,IAAelN,EAAYR,EAAImS,EAAU,CAACpM,EAAO2H,IAGpE,SAAS6E,GAAqBzU,EAAG2G,GAC7B,IAAK+N,GAAiB1U,GAClB,MAAM,IAAIuC,UAAU,GAAGoE,8BA/G/BwC,OAAOI,iBAAiB4J,GAAyB9S,UAAW,CACxDsI,OAAQ,CAAEa,YAAY,GACtBZ,KAAM,CAAEY,YAAY,GACpBN,YAAa,CAAEM,YAAY,GAC3Bf,OAAQ,CAAEe,YAAY,KAEgB,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAeyJ,GAAyB9S,UAAWf,EAAemK,YAAa,CAClF1I,MAAO,2BACP4I,cAAc,IAsHtB,MAAMgL,GAAqD,mBAApBC,gBAkBvC,MAAMC,GACFjS,YAAYkS,EAAoB,GAAIC,EAAc,SACpBvT,IAAtBsT,EACAA,EAAoB,KAGpBjO,EAAaiO,EAAmB,mBAEpC,MAAMhB,EAAWG,GAAuBc,EAAa,oBAC/CC,EArFd,SAA+BX,EAAU1N,GACrCF,EAAiB4N,EAAU1N,GAC3B,MAAMsO,EAAQZ,MAAAA,OAA2C,EAASA,EAASY,MACrE9G,EAAQkG,MAAAA,OAA2C,EAASA,EAASlG,MACrE+G,EAAQb,MAAAA,OAA2C,EAASA,EAASa,MACrEC,EAAOd,MAAAA,OAA2C,EAASA,EAASc,KACpEC,EAAQf,MAAAA,OAA2C,EAASA,EAASe,MAC3E,MAAO,CACHH,WAAiBzT,IAAVyT,OACHzT,EACA4S,GAAmCa,EAAOZ,EAAU,GAAG1N,6BAC3DwH,WAAiB3M,IAAV2M,OACH3M,EACA8S,GAAmCnG,EAAOkG,EAAU,GAAG1N,6BAC3DuO,WAAiB1T,IAAV0T,OACH1T,EACA+S,GAAmCW,EAAOb,EAAU,GAAG1N,6BAC3DyO,WAAiB5T,IAAV4T,OACH5T,EACAgT,GAAmCY,EAAOf,EAAU,GAAG1N,6BAC3DwO,KAAAA,GAiEuBE,CAAsBP,EAAmB,mBAGhE,GAFAQ,GAAyBzS,WAEZrB,IADAwT,EAAeG,KAExB,MAAM,IAAIrI,WAAW,6BAEzB,MAAMyI,EAAgBvB,GAAqBF,IA0qBnD,SAAgErP,EAAQuQ,EAAgBhC,EAAeuC,GACnG,MAAM3F,EAAazG,OAAOoJ,OAAOiD,GAAgCnV,WACjE,IAAIwS,EAAiB,OACjB4C,EAAiB,IAAM3U,OAAoBU,GAC3CkU,EAAiB,IAAM5U,OAAoBU,GAC3CmU,EAAiB,IAAM7U,OAAoBU,QAClBA,IAAzBwT,EAAeE,QACfrC,EAAiB,IAAMmC,EAAeE,MAAMtF,SAEnBpO,IAAzBwT,EAAeI,QACfK,EAAiBxN,GAAS+M,EAAeI,MAAMnN,EAAO2H,SAE7BpO,IAAzBwT,EAAe7G,QACfuH,EAAiB,IAAMV,EAAe7G,cAEb3M,IAAzBwT,EAAeC,QACfU,EAAiB1U,GAAU+T,EAAeC,MAAMhU,IAEpD2U,GAAqCnR,EAAQmL,EAAYiD,EAAgB4C,EAAgBC,EAAgBC,EAAgB3C,EAAeuC,GA1rBpIM,CAAuDhT,KAAMmS,EADvCnB,GAAqBC,EAAU,GACuCyB,GAK5FO,aACA,IAAKpB,GAAiB7R,MAClB,MAAMkT,GAA4B,UAEtC,OAAOC,GAAuBnT,MAWlCoS,MAAMhU,GACF,OAAKyT,GAAiB7R,MAGlBmT,GAAuBnT,MAChB7B,EAAoB,IAAIuB,UAAU,oDAEtC0T,GAAoBpT,KAAM5B,GALtBD,EAAoB+U,GAA4B,UAe/D5H,QACI,OAAKuG,GAAiB7R,MAGlBmT,GAAuBnT,MAChB7B,EAAoB,IAAIuB,UAAU,oDAEzC2T,GAAoCrT,MAC7B7B,EAAoB,IAAIuB,UAAU,2CAEtC4T,GAAoBtT,MARhB7B,EAAoB+U,GAA4B,UAkB/DK,YACI,IAAK1B,GAAiB7R,MAClB,MAAMkT,GAA4B,aAEtC,OAAOM,GAAmCxT,OAgBlD,SAASwT,GAAmC5R,GACxC,OAAO,IAAI6R,GAA4B7R,GAU3C,SAAS6Q,GAAyB7Q,GAC9BA,EAAOG,OAAS,WAGhBH,EAAOQ,kBAAezD,EACtBiD,EAAO8R,aAAU/U,EAGjBiD,EAAO+R,+BAA4BhV,EAGnCiD,EAAOgS,eAAiB,IAAI9T,EAG5B8B,EAAOiS,2BAAwBlV,EAG/BiD,EAAOkS,mBAAgBnV,EAGvBiD,EAAOmS,2BAAwBpV,EAE/BiD,EAAOoS,0BAAuBrV,EAE9BiD,EAAOqS,eAAgB,EAE3B,SAASpC,GAAiB1U,GACtB,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,8BAGtCA,aAAa6U,GAExB,SAASmB,GAAuBvR,GAC5B,YAAuBjD,IAAnBiD,EAAO8R,QAKf,SAASN,GAAoBxR,EAAQxD,GACjC,IAAI8J,EACJ,GAAsB,WAAlBtG,EAAOG,QAAyC,YAAlBH,EAAOG,OACrC,OAAO9D,OAAoBU,GAE/BiD,EAAO+R,0BAA0BO,aAAe9V,EACa,QAA5D8J,EAAKtG,EAAO+R,0BAA0BQ,wBAAqC,IAAPjM,GAAyBA,EAAGkK,QAIjG,MAAM5G,EAAQ5J,EAAOG,OACrB,GAAc,WAAVyJ,GAAgC,YAAVA,EACtB,OAAOvN,OAAoBU,GAE/B,QAAoCA,IAAhCiD,EAAOoS,qBACP,OAAOpS,EAAOoS,qBAAqBI,SAEvC,IAAIC,GAAqB,EACX,aAAV7I,IACA6I,GAAqB,EAErBjW,OAASO,GAEb,MAAML,EAAUP,GAAW,CAACJ,EAASG,KACjC8D,EAAOoS,qBAAuB,CAC1BI,cAAUzV,EACV2V,SAAU3W,EACV4W,QAASzW,EACT0W,QAASpW,EACTqW,oBAAqBJ,MAO7B,OAJAzS,EAAOoS,qBAAqBI,SAAW9V,EAClC+V,GACDK,GAA4B9S,EAAQxD,GAEjCE,EAEX,SAASgV,GAAoB1R,GACzB,MAAM4J,EAAQ5J,EAAOG,OACrB,GAAc,WAAVyJ,GAAgC,YAAVA,EACtB,OAAOrN,EAAoB,IAAIuB,UAAU,kBAAkB8L,+DAE/D,MAAMlN,EAAUP,GAAW,CAACJ,EAASG,KACjC,MAAM6W,EAAe,CACjBL,SAAU3W,EACV4W,QAASzW,GAEb8D,EAAOkS,cAAgBa,KAErBC,EAAShT,EAAO8R,QAghB1B,IAA8C3G,EA3gB1C,YAJepO,IAAXiW,GAAwBhT,EAAOqS,eAA2B,aAAVzI,GAChDqJ,GAAiCD,GA+gBrC7K,GAD0CgD,EA5gBLnL,EAAO+R,0BA6gBXmB,GAAe,GAChDC,GAAoDhI,GA7gB7CzO,EAaX,SAAS0W,GAAgCpT,EAAQiK,GAE/B,aADAjK,EAAOG,OAKrBkT,GAA6BrT,GAHzB8S,GAA4B9S,EAAQiK,GAK5C,SAAS6I,GAA4B9S,EAAQxD,GACzC,MAAM2O,EAAanL,EAAO+R,0BAC1B/R,EAAOG,OAAS,WAChBH,EAAOQ,aAAehE,EACtB,MAAMwW,EAAShT,EAAO8R,aACP/U,IAAXiW,GACAM,GAAsDN,EAAQxW,IA8EtE,SAAkDwD,GAC9C,YAAqCjD,IAAjCiD,EAAOiS,4BAAwElV,IAAjCiD,EAAOmS,sBA7EpDoB,CAAyCvT,IAAWmL,EAAWE,UAChEgI,GAA6BrT,GAGrC,SAASqT,GAA6BrT,GAClCA,EAAOG,OAAS,UAChBH,EAAO+R,0BAA0B3Q,KACjC,MAAMoS,EAAcxT,EAAOQ,aAK3B,GAJAR,EAAOgS,eAAezS,SAAQkU,IAC1BA,EAAad,QAAQa,MAEzBxT,EAAOgS,eAAiB,IAAI9T,OACQnB,IAAhCiD,EAAOoS,qBAEP,YADAsB,GAAkD1T,GAGtD,MAAM2T,EAAe3T,EAAOoS,qBAE5B,GADApS,EAAOoS,0BAAuBrV,EAC1B4W,EAAad,oBAGb,OAFAc,EAAahB,QAAQa,QACrBE,GAAkD1T,GAItDlD,EADgBkD,EAAO+R,0BAA0B5Q,GAAYwS,EAAaf,UACrD,KACjBe,EAAajB,WACbgB,GAAkD1T,MAClDxD,IACAmX,EAAahB,QAAQnW,GACrBkX,GAAkD1T,MAyC1D,SAASyR,GAAoCzR,GACzC,YAA6BjD,IAAzBiD,EAAOkS,oBAAgEnV,IAAjCiD,EAAOmS,sBAkBrD,SAASuB,GAAkD1T,QAC1BjD,IAAzBiD,EAAOkS,gBACPlS,EAAOkS,cAAcS,QAAQ3S,EAAOQ,cACpCR,EAAOkS,mBAAgBnV,GAE3B,MAAMiW,EAAShT,EAAO8R,aACP/U,IAAXiW,GACAY,GAAiCZ,EAAQhT,EAAOQ,cAGxD,SAASqT,GAAiC7T,EAAQ8T,GAC9C,MAAMd,EAAShT,EAAO8R,aACP/U,IAAXiW,GAAwBc,IAAiB9T,EAAOqS,gBAC5CyB,EA4jBZ,SAAwCd,GACpCe,GAAoCf,GA5jB5BgB,CAA+BhB,GAG/BC,GAAiCD,IAGzChT,EAAOqS,cAAgByB,EAlQ3BpP,OAAOI,iBAAiBsL,GAAexU,UAAW,CAC9C4U,MAAO,CAAEzL,YAAY,GACrB2E,MAAO,CAAE3E,YAAY,GACrB4M,UAAW,CAAE5M,YAAY,GACzBsM,OAAQ,CAAEtM,YAAY,KAEgB,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAemL,GAAexU,UAAWf,EAAemK,YAAa,CACxE1I,MAAO,iBACP4I,cAAc,IAgQtB,MAAM2M,GACF1T,YAAY6B,GAGR,GAFAsC,EAAuBtC,EAAQ,EAAG,+BAClCgQ,GAAqBhQ,EAAQ,mBACzBuR,GAAuBvR,GACvB,MAAM,IAAIlC,UAAU,+EAExBM,KAAK6V,qBAAuBjU,EAC5BA,EAAO8R,QAAU1T,KACjB,MAAMwL,EAAQ5J,EAAOG,OACrB,GAAc,aAAVyJ,GACK6H,GAAoCzR,IAAWA,EAAOqS,cACvD0B,GAAoC3V,MAGpC8V,GAA8C9V,MAElD+V,GAAqC/V,WAEpC,GAAc,aAAVwL,EACLwK,GAA8ChW,KAAM4B,EAAOQ,cAC3D2T,GAAqC/V,WAEpC,GAAc,WAAVwL,EACLsK,GAA8C9V,MAoetD+V,GAneuD/V,MAoevDiW,GApeuDjW,UAE9C,CACD,MAAMoV,EAAcxT,EAAOQ,aAC3B4T,GAA8ChW,KAAMoV,GACpDc,GAA+ClW,KAAMoV,IAOzDxP,aACA,OAAKuQ,GAA8BnW,MAG5BA,KAAK4C,eAFDzE,EAAoBiY,GAAiC,WAYhEhL,kBACA,IAAK+K,GAA8BnW,MAC/B,MAAMoW,GAAiC,eAE3C,QAAkCzX,IAA9BqB,KAAK6V,qBACL,MAAMQ,GAA2B,eAErC,OAuIR,SAAmDzB,GAC/C,MAAMhT,EAASgT,EAAOiB,qBAChBrK,EAAQ5J,EAAOG,OACrB,MAAc,YAAVyJ,GAAiC,aAAVA,EAChB,KAEG,WAAVA,EACO,EAEJ8K,GAA8C1U,EAAO+R,2BAhJjD4C,CAA0CvW,MAUjDuO,YACA,OAAK4H,GAA8BnW,MAG5BA,KAAKwW,cAFDrY,EAAoBiY,GAAiC,UAOpEhE,MAAMhU,GACF,OAAK+X,GAA8BnW,WAGDrB,IAA9BqB,KAAK6V,qBACE1X,EAAoBkY,GAA2B,UA4ElE,SAA0CzB,EAAQxW,GAE9C,OAAOgV,GADQwB,EAAOiB,qBACazX,GA5ExBqY,CAAiCzW,KAAM5B,GALnCD,EAAoBiY,GAAiC,UAUpE9K,QACI,IAAK6K,GAA8BnW,MAC/B,OAAO7B,EAAoBiY,GAAiC,UAEhE,MAAMxU,EAAS5B,KAAK6V,qBACpB,YAAelX,IAAXiD,EACOzD,EAAoBkY,GAA2B,UAEtDhD,GAAoCzR,GAC7BzD,EAAoB,IAAIuB,UAAU,2CAEtCgX,GAAiC1W,MAY5CqG,cACI,IAAK8P,GAA8BnW,MAC/B,MAAMoW,GAAiC,oBAG5BzX,IADAqB,KAAK6V,sBAIpBc,GAAmC3W,MAEvCuS,MAAMnN,GACF,OAAK+Q,GAA8BnW,WAGDrB,IAA9BqB,KAAK6V,qBACE1X,EAAoBkY,GAA2B,aAEnDO,GAAiC5W,KAAMoF,GALnCjH,EAAoBiY,GAAiC,WAwBxE,SAASD,GAA8BhZ,GACnC,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,yBAGtCA,aAAasW,GAOxB,SAASiD,GAAiC9B,GAEtC,OAAOtB,GADQsB,EAAOiB,sBAsB1B,SAASX,GAAsDN,EAAQ/I,GACjC,YAA9B+I,EAAOiC,mBACPC,GAAgClC,EAAQ/I,GAsXhD,SAAkD+I,EAAQxW,GACtD4X,GAA8CpB,EAAQxW,GApXlD2Y,CAAyCnC,EAAQ/I,GAczD,SAAS8K,GAAmC/B,GACxC,MAAMhT,EAASgT,EAAOiB,qBAChBmB,EAAgB,IAAItX,UAAU,oFACpCwV,GAAsDN,EAAQoC,GA9BlE,SAAgEpC,EAAQ/I,GACjC,YAA/B+I,EAAOqC,oBACPzB,GAAiCZ,EAAQ/I,GAsVjD,SAAmD+I,EAAQxW,GACvD8X,GAA+CtB,EAAQxW,GApVnD8Y,CAA0CtC,EAAQ/I,GA4BtDsL,CAAuDvC,EAAQoC,GAC/DpV,EAAO8R,aAAU/U,EACjBiW,EAAOiB,0BAAuBlX,EAElC,SAASiY,GAAiChC,EAAQxP,GAC9C,MAAMxD,EAASgT,EAAOiB,qBAChB9I,EAAanL,EAAO+R,0BACpByD,EAqKV,SAAqDrK,EAAY3H,GAC7D,IACI,OAAO2H,EAAWsK,uBAAuBjS,GAE7C,MAAOkS,GAEH,OADAC,GAA6CxK,EAAYuK,GAClD,GA3KOE,CAA4CzK,EAAY3H,GAC1E,GAAIxD,IAAWgT,EAAOiB,qBAClB,OAAO1X,EAAoBkY,GAA2B,aAE1D,MAAM7K,EAAQ5J,EAAOG,OACrB,GAAc,YAAVyJ,EACA,OAAOrN,EAAoByD,EAAOQ,cAEtC,GAAIiR,GAAoCzR,IAAqB,WAAV4J,EAC/C,OAAOrN,EAAoB,IAAIuB,UAAU,6DAE7C,GAAc,aAAV8L,EACA,OAAOrN,EAAoByD,EAAOQ,cAEtC,MAAM9D,EArXV,SAAuCsD,GAQnC,OAPgB7D,GAAW,CAACJ,EAASG,KACjC,MAAMuX,EAAe,CACjBf,SAAU3W,EACV4W,QAASzW,GAEb8D,EAAOgS,eAAepT,KAAK6U,MA+WfoC,CAA8B7V,GAE9C,OAiKJ,SAA8CmL,EAAY3H,EAAOgS,GAC7D,IACIrN,GAAqBgD,EAAY3H,EAAOgS,GAE5C,MAAOM,GAEH,YADAH,GAA6CxK,EAAY2K,GAG7D,MAAM9V,EAASmL,EAAW4K,0BACrBtE,GAAoCzR,IAA6B,aAAlBA,EAAOG,QAEvD0T,GAAiC7T,EADZgW,GAA+C7K,IAGxEgI,GAAoDhI,GA/KpD8K,CAAqC9K,EAAY3H,EAAOgS,GACjD9Y,EArGXgI,OAAOI,iBAAiB+M,GAA4BjW,UAAW,CAC3D4U,MAAO,CAAEzL,YAAY,GACrB2E,MAAO,CAAE3E,YAAY,GACrBN,YAAa,CAAEM,YAAY,GAC3B4L,MAAO,CAAE5L,YAAY,GACrBf,OAAQ,CAAEe,YAAY,GACtByE,YAAa,CAAEzE,YAAY,GAC3B4H,MAAO,CAAE5H,YAAY,KAEiB,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAe4M,GAA4BjW,UAAWf,EAAemK,YAAa,CACrF1I,MAAO,8BACP4I,cAAc,IA2FtB,MAAMgO,GAAgB,GAMtB,MAAMnC,GACF5S,cACI,MAAM,IAAIL,UAAU,uBASpBoY,kBACA,IAAKC,GAAkC/X,MACnC,MAAMgY,GAAuC,eAEjD,OAAOhY,KAAKkU,aAKZ+D,aACA,IAAKF,GAAkC/X,MACnC,MAAMgY,GAAuC,UAEjD,QAA8BrZ,IAA1BqB,KAAKmU,iBAIL,MAAM,IAAIzU,UAAU,qEAExB,OAAOM,KAAKmU,iBAAiB8D,OASjCpM,MAAMzF,GACF,IAAK2R,GAAkC/X,MACnC,MAAMgY,GAAuC,SAGnC,aADAhY,KAAK2X,0BAA0B5V,QAM7CmW,GAAqClY,KAAMoG,GAG/C,CAACrD,GAAY3E,GACT,MAAMyJ,EAAS7H,KAAKmY,gBAAgB/Z,GAEpC,OADAga,GAA+CpY,MACxC6H,EAGX,CAAC7E,KACGkH,GAAWlK,OAenB,SAAS+X,GAAkC5a,GACvC,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,8BAGtCA,aAAawV,GAExB,SAASI,GAAqCnR,EAAQmL,EAAYiD,EAAgB4C,EAAgBC,EAAgBC,EAAgB3C,EAAeuC,GAC7I3F,EAAW4K,0BAA4B/V,EACvCA,EAAO+R,0BAA4B5G,EAEnCA,EAAWnD,YAASjL,EACpBoO,EAAWlD,qBAAkBlL,EAC7BuL,GAAW6C,GACXA,EAAWmH,kBAAevV,EAC1BoO,EAAWoH,iBAlrBf,WACI,GAAIrC,GACA,OAAO,IAAIC,gBAgrBesG,GAC9BtL,EAAWE,UAAW,EACtBF,EAAWsK,uBAAyB3E,EACpC3F,EAAW8C,aAAeM,EAC1BpD,EAAWuL,gBAAkB1F,EAC7B7F,EAAWwL,gBAAkB1F,EAC7B9F,EAAWoL,gBAAkBrF,EAC7B,MAAM4C,EAAekC,GAA+C7K,GACpE0I,GAAiC7T,EAAQ8T,GAGzChX,EADqBT,EADD+R,MAEM,KACtBjD,EAAWE,UAAW,EACtB8H,GAAoDhI,MACrDqD,IACCrD,EAAWE,UAAW,EACtB+H,GAAgCpT,EAAQwO,MAwBhD,SAASgI,GAA+CrL,GACpDA,EAAWuL,qBAAkB3Z,EAC7BoO,EAAWwL,qBAAkB5Z,EAC7BoO,EAAWoL,qBAAkBxZ,EAC7BoO,EAAWsK,4BAAyB1Y,EAexC,SAAS2X,GAA8CvJ,GACnD,OAAOA,EAAW8C,aAAe9C,EAAWlD,gBAkBhD,SAASkL,GAAoDhI,GACzD,MAAMnL,EAASmL,EAAW4K,0BAC1B,IAAK5K,EAAWE,SACZ,OAEJ,QAAqCtO,IAAjCiD,EAAOiS,sBACP,OAGJ,GAAc,aADAjS,EAAOG,OAGjB,YADAkT,GAA6BrT,GAGjC,GAAiC,IAA7BmL,EAAWnD,OAAOrJ,OAClB,OAEJ,MAAMrC,EAAuB6O,EAxpDNnD,OAAOrI,OAClBrD,MAwpDRA,IAAU4W,GAYlB,SAAqD/H,GACjD,MAAMnL,EAASmL,EAAW4K,2BA1d9B,SAAgD/V,GAC5CA,EAAOmS,sBAAwBnS,EAAOkS,cACtClS,EAAOkS,mBAAgBnV,GAydvB6Z,CAAuC5W,GACvC6H,GAAasD,GACb,MAAM0L,EAAmB1L,EAAWwL,kBACpCH,GAA+CrL,GAC/CrO,EAAY+Z,GAAkB,MAxgBlC,SAA2C7W,GACvCA,EAAOmS,sBAAsBO,cAAS3V,GACtCiD,EAAOmS,2BAAwBpV,EAEjB,aADAiD,EAAOG,SAGjBH,EAAOQ,kBAAezD,OACcA,IAAhCiD,EAAOoS,uBACPpS,EAAOoS,qBAAqBM,WAC5B1S,EAAOoS,0BAAuBrV,IAGtCiD,EAAOG,OAAS,SAChB,MAAM6S,EAAShT,EAAO8R,aACP/U,IAAXiW,GACAqB,GAAkCrB,GA0flC8D,CAAkC9W,MACnCxD,KAxfP,SAAoDwD,EAAQiK,GACxDjK,EAAOmS,sBAAsBQ,QAAQ1I,GACrCjK,EAAOmS,2BAAwBpV,OAEKA,IAAhCiD,EAAOoS,uBACPpS,EAAOoS,qBAAqBO,QAAQ1I,GACpCjK,EAAOoS,0BAAuBrV,GAElCqW,GAAgCpT,EAAQiK,GAifpC8M,CAA2C/W,EAAQxD,MApBnDwa,CAA4C7L,GAuBpD,SAAqDA,EAAY3H,GAC7D,MAAMxD,EAASmL,EAAW4K,2BAle9B,SAAqD/V,GACjDA,EAAOiS,sBAAwBjS,EAAOgS,eAAe/S,QAkerDgY,CAA4CjX,GAE5ClD,EADyBqO,EAAWuL,gBAAgBlT,IACtB,MA3hBlC,SAA2CxD,GACvCA,EAAOiS,sBAAsBS,cAAS3V,GACtCiD,EAAOiS,2BAAwBlV,EA0hB3Bma,CAAkClX,GAClC,MAAM4J,EAAQ5J,EAAOG,OAErB,GADA0H,GAAasD,IACRsG,GAAoCzR,IAAqB,aAAV4J,EAAsB,CACtE,MAAMkK,EAAekC,GAA+C7K,GACpE0I,GAAiC7T,EAAQ8T,GAE7CX,GAAoDhI,MACrD3O,IACuB,aAAlBwD,EAAOG,QACPqW,GAA+CrL,GAliB3D,SAAoDnL,EAAQiK,GACxDjK,EAAOiS,sBAAsBU,QAAQ1I,GACrCjK,EAAOiS,2BAAwBlV,EAC/BqW,GAAgCpT,EAAQiK,GAiiBpCkN,CAA2CnX,EAAQxD,MArCnD4a,CAA4CjM,EAAY7O,GAGhE,SAASqZ,GAA6CxK,EAAYlB,GACV,aAAhDkB,EAAW4K,0BAA0B5V,QACrCmW,GAAqCnL,EAAYlB,GAmCzD,SAAS+L,GAA+C7K,GAEpD,OADoBuJ,GAA8CvJ,IAC5C,EAG1B,SAASmL,GAAqCnL,EAAYlB,GACtD,MAAMjK,EAASmL,EAAW4K,0BAC1BS,GAA+CrL,GAC/C2H,GAA4B9S,EAAQiK,GAGxC,SAASqH,GAA4BvQ,GACjC,OAAO,IAAIjD,UAAU,4BAA4BiD,0CAGrD,SAASqV,GAAuCrV,GAC5C,OAAO,IAAIjD,UAAU,6CAA6CiD,2DAGtE,SAASyT,GAAiCzT,GACtC,OAAO,IAAIjD,UAAU,yCAAyCiD,uDAElE,SAAS0T,GAA2B1T,GAChC,OAAO,IAAIjD,UAAU,UAAYiD,EAAO,qCAE5C,SAASoT,GAAqCnB,GAC1CA,EAAOhS,eAAiB7E,GAAW,CAACJ,EAASG,KACzC8W,EAAO/R,uBAAyBlF,EAChCiX,EAAO9R,sBAAwBhF,EAC/B8W,EAAOqC,oBAAsB,aAGrC,SAASf,GAA+CtB,EAAQxW,GAC5D2X,GAAqCnB,GACrCY,GAAiCZ,EAAQxW,GAM7C,SAASoX,GAAiCZ,EAAQxW,QACTO,IAAjCiW,EAAO9R,wBAGX7D,EAA0B2V,EAAOhS,gBACjCgS,EAAO9R,sBAAsB1E,GAC7BwW,EAAO/R,4BAAyBlE,EAChCiW,EAAO9R,2BAAwBnE,EAC/BiW,EAAOqC,oBAAsB,YAKjC,SAAShB,GAAkCrB,QACDjW,IAAlCiW,EAAO/R,yBAGX+R,EAAO/R,4BAAuBlE,GAC9BiW,EAAO/R,4BAAyBlE,EAChCiW,EAAO9R,2BAAwBnE,EAC/BiW,EAAOqC,oBAAsB,YAEjC,SAAStB,GAAoCf,GACzCA,EAAO4B,cAAgBzY,GAAW,CAACJ,EAASG,KACxC8W,EAAOqE,sBAAwBtb,EAC/BiX,EAAOsE,qBAAuBpb,KAElC8W,EAAOiC,mBAAqB,UAEhC,SAASb,GAA8CpB,EAAQxW,GAC3DuX,GAAoCf,GACpCkC,GAAgClC,EAAQxW,GAE5C,SAAS0X,GAA8ClB,GACnDe,GAAoCf,GACpCC,GAAiCD,GAErC,SAASkC,GAAgClC,EAAQxW,QACTO,IAAhCiW,EAAOsE,uBAGXja,EAA0B2V,EAAO4B,eACjC5B,EAAOsE,qBAAqB9a,GAC5BwW,EAAOqE,2BAAwBta,EAC/BiW,EAAOsE,0BAAuBva,EAC9BiW,EAAOiC,mBAAqB,YAQhC,SAAShC,GAAiCD,QACDjW,IAAjCiW,EAAOqE,wBAGXrE,EAAOqE,2BAAsBta,GAC7BiW,EAAOqE,2BAAwBta,EAC/BiW,EAAOsE,0BAAuBva,EAC9BiW,EAAOiC,mBAAqB,aA5QhCvQ,OAAOI,iBAAiBiM,GAAgCnV,UAAW,CAC/Dsa,YAAa,CAAEnR,YAAY,GAC3BsR,OAAQ,CAAEtR,YAAY,GACtBkF,MAAO,CAAElF,YAAY,KAEiB,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAe8L,GAAgCnV,UAAWf,EAAemK,YAAa,CACzF1I,MAAO,kCACP4I,cAAc,IAwQtB,MAAMqS,GAA6C,oBAAjBC,aAA+BA,kBAAeza,EA6B1E0a,GA1BN,SAAmCxI,GAC/B,GAAsB,mBAATA,GAAuC,iBAATA,EACvC,OAAO,EAEX,IAEI,OADA,IAAIA,GACG,EAEX,MAAO3I,GACH,OAAO,GAiBQoR,CAA0BH,IAAsBA,GAdvE,WAEI,MAAMtI,EAAO,SAAsB0I,EAAS5W,GACxC3C,KAAKuZ,QAAUA,GAAW,GAC1BvZ,KAAK2C,KAAOA,GAAQ,QAChB6W,MAAMC,mBACND,MAAMC,kBAAkBzZ,KAAMA,KAAKD,cAK3C,OAFA8Q,EAAKrT,UAAY8I,OAAOoJ,OAAO8J,MAAMhc,WACrC8I,OAAOO,eAAegK,EAAKrT,UAAW,cAAe,CAAEU,MAAO2S,EAAM6I,UAAU,EAAM5S,cAAc,IAC3F+J,EAGiF8I,GAE5F,SAASC,GAAqBC,EAAQpR,EAAMqR,EAAcC,EAAc5S,EAAe8Q,GACnF,MAAMtW,EAASmD,EAAmC+U,GAC5CjF,EAASpB,GAAmC/K,GAClDoR,EAAOrT,YAAa,EACpB,IAAIwT,GAAe,EAEfC,EAAehc,OAAoBU,GACvC,OAAOZ,GAAW,CAACJ,EAASG,KACxB,IAAIgV,EACJ,QAAenU,IAAXsZ,EAAsB,CAsBtB,GArBAnF,EAAiB,KACb,MAAMjH,EAAQ,IAAIwN,GAAe,UAAW,cACtCa,EAAU,GACXH,GACDG,EAAQ1Z,MAAK,IACW,aAAhBiI,EAAK1G,OACEqR,GAAoB3K,EAAMoD,GAE9B5N,OAAoBU,KAG9BwI,GACD+S,EAAQ1Z,MAAK,IACa,aAAlBqZ,EAAO9X,OACAO,GAAqBuX,EAAQhO,GAEjC5N,OAAoBU,KAGnCwb,GAAmB,IAAM7c,QAAQ8c,IAAIF,EAAQG,KAAIC,GAAUA,SAAY,EAAMzO,IAE7EoM,EAAOsC,QAEP,YADAzH,IAGJmF,EAAOuC,iBAAiB,QAAS1H,GAyFrC,IAA2BlR,EAAQtD,EAASgc,EAxB5C,GA3BAG,EAAmBZ,EAAQlY,EAAOiB,gBAAgBwS,IACzC2E,EAIDW,GAAS,EAAMtF,GAHf+E,GAAmB,IAAM/G,GAAoB3K,EAAM2M,KAAc,EAAMA,MAO/EqF,EAAmBhS,EAAMmM,EAAOhS,gBAAgBwS,IACvCjO,EAIDuT,GAAS,EAAMtF,GAHf+E,GAAmB,IAAM7X,GAAqBuX,EAAQzE,KAAc,EAAMA,MAwCvDxT,EAjCTiY,EAiCiBvb,EAjCTqD,EAAOiB,eAiCW0X,EAjCK,KACxCR,EAIDY,IAHAP,GAAmB,IArhBnC,SAA8DvF,GAC1D,MAAMhT,EAASgT,EAAOiB,qBAChBrK,EAAQ5J,EAAOG,OACrB,OAAIsR,GAAoCzR,IAAqB,WAAV4J,EACxCvN,OAAoBU,GAEjB,YAAV6M,EACOrN,EAAoByD,EAAOQ,cAE/BsU,GAAiC9B,GA4gBH+F,CAAqD/F,MAgC5D,WAAlBhT,EAAOG,OACPuY,IAGA1b,EAAgBN,EAASgc,GA7B7BjH,GAAoC5K,IAAyB,WAAhBA,EAAK1G,OAAqB,CACvE,MAAM6Y,EAAa,IAAIlb,UAAU,+EAC5ByH,EAIDuT,GAAS,EAAME,GAHfT,GAAmB,IAAM7X,GAAqBuX,EAAQe,KAAa,EAAMA,GAOjF,SAASC,IAGL,MAAMC,EAAkBb,EACxB,OAAO5b,EAAmB4b,GAAc,IAAMa,IAAoBb,EAAeY,SAA0Blc,IAE/G,SAAS8b,EAAmB7Y,EAAQtD,EAASgc,GACnB,YAAlB1Y,EAAOG,OACPuY,EAAO1Y,EAAOQ,cAGdvD,EAAcP,EAASgc,GAW/B,SAASH,EAAmBG,EAAQS,EAAiBC,GAWjD,SAASC,IACLvc,EAAY4b,KAAU,IAAMY,EAASH,EAAiBC,KAAgBG,GAAYD,GAAS,EAAMC,KAXjGnB,IAGJA,GAAe,EACK,aAAhBvR,EAAK1G,QAA0BsR,GAAoC5K,GAInEwS,IAHArc,EAAgBic,IAAyBI,IASjD,SAASP,EAASU,EAASvP,GACnBmO,IAGJA,GAAe,EACK,aAAhBvR,EAAK1G,QAA0BsR,GAAoC5K,GAInEyS,EAASE,EAASvP,GAHlBjN,EAAgBic,KAAyB,IAAMK,EAASE,EAASvP,MAMzE,SAASqP,EAASE,EAASvP,GACvB8K,GAAmC/B,GACnCrS,EAAmCZ,QACpBhD,IAAXsZ,GACAA,EAAOoD,oBAAoB,QAASvI,GAEpCsI,EACAtd,EAAO+N,GAGPlO,OAAQgB,GA5DhBM,EApEWlB,GAAW,CAACud,EAAaC,MAC5B,SAAShU,EAAKlC,GACNA,EACAiW,IAKAjd,EAOR2b,EACO/b,GAAoB,GAExBI,EAAmBuW,EAAO4B,eAAe,IACrCzY,GAAW,CAACyd,EAAaC,KAC5BvV,GAAgCvE,EAAQ,CACpC4D,YAAaH,IACT6U,EAAe5b,EAAmBuY,GAAiChC,EAAQxP,QAAQzG,EAAW9B,GAC9F2e,GAAY,IAEhBlW,YAAa,IAAMkW,GAAY,GAC/BrV,YAAasV,SAlBkBlU,EAAMgU,GAG7ChU,EAAK,UAgIrB,MAAMmU,GACF3b,cACI,MAAM,IAAIL,UAAU,uBAMpB0L,kBACA,IAAKuQ,GAAkC3b,MACnC,MAAM4b,GAAuC,eAEjD,OAAOC,GAA8C7b,MAMzDsL,QACI,IAAKqQ,GAAkC3b,MACnC,MAAM4b,GAAuC,SAEjD,IAAKE,GAAiD9b,MAClD,MAAM,IAAIN,UAAU,mDAExBqc,GAAqC/b,MAEzC2L,QAAQvG,GACJ,IAAKuW,GAAkC3b,MACnC,MAAM4b,GAAuC,WAEjD,IAAKE,GAAiD9b,MAClD,MAAM,IAAIN,UAAU,qDAExB,OAAOsc,GAAuChc,KAAMoF,GAKxDyG,MAAMzF,GACF,IAAKuV,GAAkC3b,MACnC,MAAM4b,GAAuC,SAEjDK,GAAqCjc,KAAMoG,GAG/C,CAACnD,GAAa7E,GACV8L,GAAWlK,MACX,MAAM6H,EAAS7H,KAAKgM,iBAAiB5N,GAErC,OADA8d,GAA+Clc,MACxC6H,EAGX,CAAC3E,GAAW+B,GACR,MAAMrD,EAAS5B,KAAKmc,0BACpB,GAAInc,KAAK4J,OAAOrJ,OAAS,EAAG,CACxB,MAAM6E,EAAQqE,GAAazJ,MACvBA,KAAKuL,iBAA0C,IAAvBvL,KAAK4J,OAAOrJ,QACpC2b,GAA+Clc,MAC/C6O,GAAoBjN,IAGpBwa,GAAgDpc,MAEpDiF,EAAYM,YAAYH,QAGxBJ,EAA6BpD,EAAQqD,GACrCmX,GAAgDpc,OAiB5D,SAAS2b,GAAkCxe,GACvC,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,8BAGtCA,aAAaue,GAExB,SAASU,GAAgDrP,GAClCsP,GAA8CtP,KAI7DA,EAAWM,SACXN,EAAWO,YAAa,GAG5BP,EAAWM,UAAW,EAEtB3O,EADoBqO,EAAWQ,kBACN,KACrBR,EAAWM,UAAW,EAClBN,EAAWO,aACXP,EAAWO,YAAa,EACxB8O,GAAgDrP,OAErD3G,IACC6V,GAAqClP,EAAY3G,QAGzD,SAASiW,GAA8CtP,GACnD,MAAMnL,EAASmL,EAAWoP,0BAC1B,QAAKL,GAAiD/O,OAGjDA,EAAWE,cAGZtH,GAAuB/D,IAAW4D,EAAiC5D,GAAU,IAG7Dia,GAA8C9O,GAChD,IAKtB,SAASmP,GAA+CnP,GACpDA,EAAWQ,oBAAiB5O,EAC5BoO,EAAWf,sBAAmBrN,EAC9BoO,EAAWsK,4BAAyB1Y,EAGxC,SAASod,GAAqChP,GAC1C,IAAK+O,GAAiD/O,GAClD,OAEJ,MAAMnL,EAASmL,EAAWoP,0BAC1BpP,EAAWxB,iBAAkB,EACI,IAA7BwB,EAAWnD,OAAOrJ,SAClB2b,GAA+CnP,GAC/C8B,GAAoBjN,IAG5B,SAASoa,GAAuCjP,EAAY3H,GACxD,IAAK0W,GAAiD/O,GAClD,OAEJ,MAAMnL,EAASmL,EAAWoP,0BAC1B,GAAIxW,GAAuB/D,IAAW4D,EAAiC5D,GAAU,EAC7EuD,EAAiCvD,EAAQwD,GAAO,OAE/C,CACD,IAAIgS,EACJ,IACIA,EAAYrK,EAAWsK,uBAAuBjS,GAElD,MAAOkS,GAEH,MADA2E,GAAqClP,EAAYuK,GAC3CA,EAEV,IACIvN,GAAqBgD,EAAY3H,EAAOgS,GAE5C,MAAOM,GAEH,MADAuE,GAAqClP,EAAY2K,GAC3CA,GAGd0E,GAAgDrP,GAEpD,SAASkP,GAAqClP,EAAY3G,GACtD,MAAMxE,EAASmL,EAAWoP,0BACJ,aAAlBva,EAAOG,SAGXmI,GAAW6C,GACXmP,GAA+CnP,GAC/C0C,GAAoB7N,EAAQwE,IAEhC,SAASyV,GAA8C9O,GACnD,MAAMvB,EAAQuB,EAAWoP,0BAA0Bpa,OACnD,MAAc,YAAVyJ,EACO,KAEG,WAAVA,EACO,EAEJuB,EAAW8C,aAAe9C,EAAWlD,gBAShD,SAASiS,GAAiD/O,GACtD,MAAMvB,EAAQuB,EAAWoP,0BAA0Bpa,OACnD,OAAKgL,EAAWxB,iBAA6B,aAAVC,EAKvC,SAAS8Q,GAAqC1a,EAAQmL,EAAYiD,EAAgBC,EAAeC,EAAiBC,EAAeuC,GAC7H3F,EAAWoP,0BAA4Bva,EACvCmL,EAAWnD,YAASjL,EACpBoO,EAAWlD,qBAAkBlL,EAC7BuL,GAAW6C,GACXA,EAAWE,UAAW,EACtBF,EAAWxB,iBAAkB,EAC7BwB,EAAWO,YAAa,EACxBP,EAAWM,UAAW,EACtBN,EAAWsK,uBAAyB3E,EACpC3F,EAAW8C,aAAeM,EAC1BpD,EAAWQ,eAAiB0C,EAC5BlD,EAAWf,iBAAmBkE,EAC9BtO,EAAO6E,0BAA4BsG,EAEnCrO,EAAYT,EADQ+R,MAC0B,KAC1CjD,EAAWE,UAAW,EACtBmP,GAAgDrP,MACjDqD,IACC6L,GAAqClP,EAAYqD,MAoBzD,SAASwL,GAAuCjZ,GAC5C,OAAO,IAAIjD,UAAU,6CAA6CiD,2DAsWtE,SAAS4Z,GAAsCld,EAAImS,EAAU1N,GAEzD,OADAC,EAAe1E,EAAIyE,GACX1F,GAAWyB,EAAYR,EAAImS,EAAU,CAACpT,IAElD,SAASoe,GAAoCnd,EAAImS,EAAU1N,GAEvD,OADAC,EAAe1E,EAAIyE,GACXiJ,GAAelN,EAAYR,EAAImS,EAAU,CAACzE,IAEtD,SAAS0P,GAAqCpd,EAAImS,EAAU1N,GAExD,OADAC,EAAe1E,EAAIyE,GACXiJ,GAAezN,EAAYD,EAAImS,EAAU,CAACzE,IAEtD,SAAS2P,GAA0BpK,EAAMxO,GAErC,GAAa,UADbwO,EAAO,GAAGA,KAEN,MAAM,IAAI5S,UAAU,GAAGoE,MAAYwO,8DAEvC,OAAOA,EAUX,SAASqK,GAAgCC,EAAM9Y,GAE3C,GAAa,SADb8Y,EAAO,GAAGA,KAEN,MAAM,IAAIld,UAAU,GAAGoE,MAAY8Y,oEAEvC,OAAOA,EASX,SAASC,GAAmBC,EAAShZ,GACjCF,EAAiBkZ,EAAShZ,GAC1B,MAAMiW,EAAe+C,MAAAA,OAAyC,EAASA,EAAQ/C,aACzE5S,EAAgB2V,MAAAA,OAAyC,EAASA,EAAQ3V,cAC1E2S,EAAegD,MAAAA,OAAyC,EAASA,EAAQhD,aACzE7B,EAAS6E,MAAAA,OAAyC,EAASA,EAAQ7E,OAIzE,YAHetZ,IAAXsZ,GAUR,SAA2BA,EAAQnU,GAC/B,IAnyDJ,SAAuB5F,GACnB,GAAqB,iBAAVA,GAAgC,OAAVA,EAC7B,OAAO,EAEX,IACI,MAAgC,kBAAlBA,EAAMqc,QAExB,MAAOrS,GAEH,OAAO,GA0xDN6U,CAAc9E,GACf,MAAM,IAAIvY,UAAU,GAAGoE,4BAXvBkZ,CAAkB/E,EAAQ,GAAGnU,8BAE1B,CACHiW,aAAckD,QAAQlD,GACtB5S,cAAe8V,QAAQ9V,GACvB2S,aAAcmD,QAAQnD,GACtB7B,OAAAA,GA7kBR3R,OAAOI,iBAAiBgV,GAAgCle,UAAW,CAC/D8N,MAAO,CAAE3E,YAAY,GACrBgF,QAAS,CAAEhF,YAAY,GACvBkF,MAAO,CAAElF,YAAY,GACrByE,YAAa,CAAEzE,YAAY,KAEW,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAe6U,GAAgCle,UAAWf,EAAemK,YAAa,CACzF1I,MAAO,kCACP4I,cAAc,IA6lBtB,MAAMoW,GACFnd,YAAYod,EAAsB,GAAIjL,EAAc,SACpBvT,IAAxBwe,EACAA,EAAsB,KAGtBnZ,EAAamZ,EAAqB,mBAEtC,MAAMlM,EAAWG,GAAuBc,EAAa,oBAC/CkL,EAhHd,SAA8CvD,EAAQ/V,GAClDF,EAAiBiW,EAAQ/V,GACzB,MAAM0N,EAAWqI,EACXzN,EAAwBoF,MAAAA,OAA2C,EAASA,EAASpF,sBACrFtG,EAAS0L,MAAAA,OAA2C,EAASA,EAAS1L,OACtEuX,EAAO7L,MAAAA,OAA2C,EAASA,EAAS6L,KACpEhL,EAAQb,MAAAA,OAA2C,EAASA,EAASa,MACrEC,EAAOd,MAAAA,OAA2C,EAASA,EAASc,KAC1E,MAAO,CACHlG,2BAAiDzN,IAA1ByN,OACnBzN,EACA6F,EAAwC4H,EAAuB,GAAGtI,6CACtEgC,YAAmBnH,IAAXmH,OACJnH,EACA4d,GAAsCzW,EAAQ0L,EAAU,GAAG1N,8BAC/DuZ,UAAe1e,IAAT0e,OACF1e,EACA6d,GAAoCa,EAAM7L,EAAU,GAAG1N,4BAC3DuO,WAAiB1T,IAAV0T,OACH1T,EACA8d,GAAqCpK,EAAOb,EAAU,GAAG1N,6BAC7DwO,UAAe3T,IAAT2T,OAAqB3T,EAAY+d,GAA0BpK,EAAM,GAAGxO,6BA2FjDwZ,CAAqCH,EAAqB,mBAEnF,GADAI,GAAyBvd,MACK,UAA1Bod,EAAiB9K,KAAkB,CACnC,QAAsB3T,IAAlBsS,EAASnH,KACT,MAAM,IAAIG,WAAW,+DA3lErC,SAA+DrI,EAAQ4b,EAAsBrN,GACzF,MAAMpD,EAAazG,OAAOoJ,OAAO3E,GAA6BvN,WAC9D,IAAIwS,EAAiB,OACjBC,EAAgB,IAAMhS,OAAoBU,GAC1CuR,EAAkB,IAAMjS,OAAoBU,QACbA,IAA/B6e,EAAqBnL,QACrBrC,EAAiB,IAAMwN,EAAqBnL,MAAMtF,SAEpBpO,IAA9B6e,EAAqBH,OACrBpN,EAAgB,IAAMuN,EAAqBH,KAAKtQ,SAEhBpO,IAAhC6e,EAAqB1X,SACrBoK,EAAkB9R,GAAUof,EAAqB1X,OAAO1H,IAE5D,MAAMgO,EAAwBoR,EAAqBpR,sBACnD,GAA8B,IAA1BA,EACA,MAAM,IAAI1M,UAAU,gDAExBqQ,GAAkCnO,EAAQmL,EAAYiD,EAAgBC,EAAeC,EAAiBC,EAAe/D,GA4kE7GqR,CAAsDzd,KAAMod,EADtCpM,GAAqBC,EAAU,QAGpD,CACD,MAAMyB,EAAgBvB,GAAqBF,IA1dvD,SAAkErP,EAAQwb,EAAkBjN,EAAeuC,GACvG,MAAM3F,EAAazG,OAAOoJ,OAAOgM,GAAgCle,WACjE,IAAIwS,EAAiB,OACjBC,EAAgB,IAAMhS,OAAoBU,GAC1CuR,EAAkB,IAAMjS,OAAoBU,QACjBA,IAA3Bye,EAAiB/K,QACjBrC,EAAiB,IAAMoN,EAAiB/K,MAAMtF,SAEpBpO,IAA1Bye,EAAiBC,OACjBpN,EAAgB,IAAMmN,EAAiBC,KAAKtQ,SAEhBpO,IAA5Bye,EAAiBtX,SACjBoK,EAAkB9R,GAAUgf,EAAiBtX,OAAO1H,IAExDke,GAAqC1a,EAAQmL,EAAYiD,EAAgBC,EAAeC,EAAiBC,EAAeuC,GA8chHgL,CAAyD1d,KAAMod,EADzCpM,GAAqBC,EAAU,GAC2CyB,IAMpGO,aACA,IAAKpO,GAAiB7E,MAClB,MAAM2d,GAA4B,UAEtC,OAAOhY,GAAuB3F,MAQlC8F,OAAO1H,GACH,OAAKyG,GAAiB7E,MAGlB2F,GAAuB3F,MAChB7B,EAAoB,IAAIuB,UAAU,qDAEtC4C,GAAqBtC,KAAM5B,GALvBD,EAAoBwf,GAA4B,WAO/DC,UAAUC,GACN,IAAKhZ,GAAiB7E,MAClB,MAAM2d,GAA4B,aAGtC,YAAqBhf,IAhH7B,SAA8Bme,EAAShZ,GACnCF,EAAiBkZ,EAAShZ,GAC1B,MAAM8Y,EAAOE,MAAAA,OAAyC,EAASA,EAAQF,KACvE,MAAO,CACHA,UAAeje,IAATie,OAAqBje,EAAYge,GAAgCC,EAAM,GAAG9Y,6BA2GhEga,CAAqBD,EAAY,mBACrCjB,KACD9X,EAAmC9E,MAEvCqQ,GAAgCrQ,MAE3C+d,YAAYC,EAAcH,EAAa,IACnC,IAAKhZ,GAAiB7E,MAClB,MAAM2d,GAA4B,eAEtCzZ,EAAuB8Z,EAAc,EAAG,eACxC,MAAMC,EA/Ed,SAAqCtU,EAAM7F,GACvCF,EAAiB+F,EAAM7F,GACvB,MAAMoa,EAAWvU,MAAAA,OAAmC,EAASA,EAAKuU,SAClE9Z,EAAoB8Z,EAAU,WAAY,wBAC1CtZ,EAAqBsZ,EAAU,GAAGpa,gCAClC,MAAM4V,EAAW/P,MAAAA,OAAmC,EAASA,EAAK+P,SAGlE,OAFAtV,EAAoBsV,EAAU,WAAY,wBAC1C9H,GAAqB8H,EAAU,GAAG5V,gCAC3B,CAAEoa,SAAAA,EAAUxE,SAAAA,GAuEGyE,CAA4BH,EAAc,mBACtDlB,EAAUD,GAAmBgB,EAAY,oBAC/C,GAAIlY,GAAuB3F,MACvB,MAAM,IAAIN,UAAU,kFAExB,GAAIyT,GAAuB8K,EAAUvE,UACjC,MAAM,IAAIha,UAAU,kFAIxB,OADAT,EADgB2a,GAAqB5Z,KAAMie,EAAUvE,SAAUoD,EAAQhD,aAAcgD,EAAQ/C,aAAc+C,EAAQ3V,cAAe2V,EAAQ7E,SAEnIgG,EAAUC,SAErBE,OAAOC,EAAaR,EAAa,IAC7B,IAAKhZ,GAAiB7E,MAClB,OAAO7B,EAAoBwf,GAA4B,WAE3D,QAAoBhf,IAAhB0f,EACA,OAAOlgB,EAAoB,wCAE/B,IAAK0T,GAAiBwM,GAClB,OAAOlgB,EAAoB,IAAIuB,UAAU,8EAE7C,IAAIod,EACJ,IACIA,EAAUD,GAAmBgB,EAAY,oBAE7C,MAAOzX,GACH,OAAOjI,EAAoBiI,GAE/B,OAAIT,GAAuB3F,MAChB7B,EAAoB,IAAIuB,UAAU,8EAEzCyT,GAAuBkL,GAChBlgB,EAAoB,IAAIuB,UAAU,8EAEtCka,GAAqB5Z,KAAMqe,EAAavB,EAAQhD,aAAcgD,EAAQ/C,aAAc+C,EAAQ3V,cAAe2V,EAAQ7E,QAa9HqG,MACI,IAAKzZ,GAAiB7E,MAClB,MAAM2d,GAA4B,OAGtC,OAAOrV,GAriBP2C,IADmBrJ,EAqiBgB5B,MApiBGyG,2BAwG9C,SAA+B7E,GAC3B,IAMI2c,EACAC,EACAC,EACAC,EACAC,EAVAhd,EAASmD,EAAmClD,GAC5Cgd,GAAU,EACVC,GAAsB,EACtBC,GAAsB,EACtBC,GAAY,EACZC,GAAY,EAMhB,MAAMC,EAAgBlhB,GAAWJ,IAC7BghB,EAAuBhhB,KAE3B,SAASuhB,EAAmBC,GACxBtgB,EAAcsgB,EAAWvc,gBAAgBwN,IACjC+O,IAAexd,IAGnBmK,GAAkC2S,EAAQhY,0BAA2B2J,GACrEtE,GAAkC4S,EAAQjY,0BAA2B2J,GAChE2O,GAAcC,GACfL,OAAqBhgB,OAIjC,SAASygB,IACD5O,GAA2B7O,KAC3BY,EAAmCZ,GACnCA,EAASmD,EAAmClD,GAC5Csd,EAAmBvd,IA4DvBuE,GAAgCvE,EA1DZ,CAChB4D,YAAaH,IAITlG,GAAe,KACX2f,GAAsB,EACtBC,GAAsB,EACtB,MAAMO,EAASja,EACf,IAAIka,EAASla,EACb,IAAK2Z,IAAcC,EACf,IACIM,EAASjW,GAAkBjE,GAE/B,MAAOma,GAIH,OAHAzT,GAAkC2S,EAAQhY,0BAA2B8Y,GACrEzT,GAAkC4S,EAAQjY,0BAA2B8Y,QACrEZ,EAAqBrc,GAAqBV,EAAQ2d,IAIrDR,GACDnT,GAAoC6S,EAAQhY,0BAA2B4Y,GAEtEL,GACDpT,GAAoC8S,EAAQjY,0BAA2B6Y,GAE3EV,GAAU,EACNC,EACAW,IAEKV,GACLW,QAIZna,YAAa,KACTsZ,GAAU,EACLG,GACDrT,GAAkC+S,EAAQhY,2BAEzCuY,GACDtT,GAAkCgT,EAAQjY,2BAE1CgY,EAAQhY,0BAA0BoG,kBAAkBtM,OAAS,GAC7DoK,GAAoC8T,EAAQhY,0BAA2B,GAEvEiY,EAAQjY,0BAA0BoG,kBAAkBtM,OAAS,GAC7DoK,GAAoC+T,EAAQjY,0BAA2B,GAEtEsY,GAAcC,GACfL,OAAqBhgB,IAG7BwH,YAAa,KACTyY,GAAU,KAKtB,SAASc,EAAmBtV,EAAMuV,GAC1Bja,GAA8B/D,KAC9BY,EAAmCZ,GACnCA,EAAS0O,GAAgCzO,GACzCsd,EAAmBvd,IAEvB,MAAMie,EAAaD,EAAajB,EAAUD,EACpCoB,EAAcF,EAAalB,EAAUC,EAiE3ChO,GAA6B/O,EAAQyI,EAhEb,CACpB7E,YAAaH,IAITlG,GAAe,KACX2f,GAAsB,EACtBC,GAAsB,EACtB,MAAMgB,EAAeH,EAAaX,EAAYD,EAE9C,GADsBY,EAAaZ,EAAYC,EAiBrCc,GACNhV,GAA+C8U,EAAWnZ,0BAA2BrB,OAjBrE,CAChB,IAAI2a,EACJ,IACIA,EAAc1W,GAAkBjE,GAEpC,MAAOma,GAIH,OAHAzT,GAAkC8T,EAAWnZ,0BAA2B8Y,GACxEzT,GAAkC+T,EAAYpZ,0BAA2B8Y,QACzEZ,EAAqBrc,GAAqBV,EAAQ2d,IAGjDO,GACDhV,GAA+C8U,EAAWnZ,0BAA2BrB,GAEzFwG,GAAoCiU,EAAYpZ,0BAA2BsZ,GAK/EnB,GAAU,EACNC,EACAW,IAEKV,GACLW,QAIZna,YAAaF,IACTwZ,GAAU,EACV,MAAMkB,EAAeH,EAAaX,EAAYD,EACxCiB,EAAgBL,EAAaZ,EAAYC,EAC1Cc,GACDpU,GAAkCkU,EAAWnZ,2BAE5CuZ,GACDtU,GAAkCmU,EAAYpZ,gCAEpC9H,IAAVyG,IACK0a,GACDhV,GAA+C8U,EAAWnZ,0BAA2BrB,IAEpF4a,GAAiBH,EAAYpZ,0BAA0BoG,kBAAkBtM,OAAS,GACnFoK,GAAoCkV,EAAYpZ,0BAA2B,IAG9EqZ,GAAiBE,GAClBrB,OAAqBhgB,IAG7BwH,YAAa,KACTyY,GAAU,KAKtB,SAASY,IACL,GAAIZ,EAEA,OADAC,GAAsB,EACf5gB,OAAoBU,GAE/BigB,GAAU,EACV,MAAM5T,EAAcG,GAA2CsT,EAAQhY,2BAOvE,OANoB,OAAhBuE,EACAoU,IAGAM,EAAmB1U,EAAYT,OAAO,GAEnCtM,OAAoBU,GAE/B,SAAS8gB,IACL,GAAIb,EAEA,OADAE,GAAsB,EACf7gB,OAAoBU,GAE/BigB,GAAU,EACV,MAAM5T,EAAcG,GAA2CuT,EAAQjY,2BAOvE,OANoB,OAAhBuE,EACAoU,IAGAM,EAAmB1U,EAAYT,OAAO,GAEnCtM,OAAoBU,GAsB/B,SAASqR,KAMT,OAHAyO,EAAUwB,GAAyBjQ,EAAgBwP,GAvBnD,SAA0BphB,GAGtB,GAFA2gB,GAAY,EACZR,EAAUngB,EACN4gB,EAAW,CACX,MAAMkB,EAAkB5X,GAAoB,CAACiW,EAASC,IAChD2B,EAAe7d,GAAqBV,EAAQse,GAClDvB,EAAqBwB,GAEzB,OAAOlB,KAgBXP,EAAUuB,GAAyBjQ,EAAgByP,GAdnD,SAA0BrhB,GAGtB,GAFA4gB,GAAY,EACZR,EAAUpgB,EACN2gB,EAAW,CACX,MAAMmB,EAAkB5X,GAAoB,CAACiW,EAASC,IAChD2B,EAAe7d,GAAqBV,EAAQse,GAClDvB,EAAqBwB,GAEzB,OAAOlB,KAOXC,EAAmBvd,GACZ,CAAC8c,EAASC,GAtUN0B,CAAsBxe,GAIrC,SAAkCA,EAAQye,GACtC,MAAM1e,EAASmD,EAAmClD,GAClD,IAII2c,EACAC,EACAC,EACAC,EACAC,EARAC,GAAU,EACV0B,GAAY,EACZvB,GAAY,EACZC,GAAY,EAMhB,MAAMC,EAAgBlhB,GAAWJ,IAC7BghB,EAAuBhhB,KAE3B,SAASsS,IACL,OAAI2O,GACA0B,GAAY,EACLriB,OAAoBU,KAE/BigB,GAAU,EA2CV1Y,GAAgCvE,EA1CZ,CAChB4D,YAAaH,IAITlG,GAAe,KACXohB,GAAY,EACZ,MAAMjB,EAASja,EACTka,EAASla,EAMV2Z,GACD/C,GAAuCyC,EAAQhY,0BAA2B4Y,GAEzEL,GACDhD,GAAuC0C,EAAQjY,0BAA2B6Y,GAE9EV,GAAU,EACN0B,GACArQ,QAIZ3K,YAAa,KACTsZ,GAAU,EACLG,GACDhD,GAAqC0C,EAAQhY,2BAE5CuY,GACDjD,GAAqC2C,EAAQjY,2BAE5CsY,GAAcC,GACfL,OAAqBhgB,IAG7BwH,YAAa,KACTyY,GAAU,KAIX3gB,OAAoBU,IAsB/B,SAASqR,KAYT,OATAyO,EAAU8B,GAAqBvQ,EAAgBC,GAvB/C,SAA0B7R,GAGtB,GAFA2gB,GAAY,EACZR,EAAUngB,EACN4gB,EAAW,CACX,MAAMkB,EAAkB5X,GAAoB,CAACiW,EAASC,IAChD2B,EAAe7d,GAAqBV,EAAQse,GAClDvB,EAAqBwB,GAEzB,OAAOlB,KAgBXP,EAAU6B,GAAqBvQ,EAAgBC,GAd/C,SAA0B7R,GAGtB,GAFA4gB,GAAY,EACZR,EAAUpgB,EACN2gB,EAAW,CACX,MAAMmB,EAAkB5X,GAAoB,CAACiW,EAASC,IAChD2B,EAAe7d,GAAqBV,EAAQse,GAClDvB,EAAqBwB,GAEzB,OAAOlB,KAOXpgB,EAAc8C,EAAOiB,gBAAiBwN,IAClC6L,GAAqCwC,EAAQhY,0BAA2B2J,GACxE6L,GAAqCyC,EAAQjY,0BAA2B2J,GACnE2O,GAAcC,GACfL,OAAqBhgB,MAGtB,CAAC8f,EAASC,GAnGV8B,CAAyB5e,IAJpC,IAA2BA,EAwiBvB6e,OAAO5C,GACH,IAAKhZ,GAAiB7E,MAClB,MAAM2d,GAA4B,UAGtC,OA14FR,SAA4C/b,EAAQuF,GAChD,MAAMxF,EAASmD,EAAmClD,GAC5C8e,EAAO,IAAIxZ,GAAgCvF,EAAQwF,GACnDxK,EAAW2J,OAAOoJ,OAAO5H,IAE/B,OADAnL,EAASqL,mBAAqB0Y,EACvB/jB,EAq4FIgkB,CAAmC3gB,KAvKlD,SAAgC8c,EAAShZ,GACrCF,EAAiBkZ,EAqKsC,mBApKvD,MAAM3V,EAAgB2V,MAAAA,OAAyC,EAASA,EAAQ3V,cAChF,MAAO,CAAEA,cAAe8V,QAAQ9V,IAmKZyZ,CAAuB/C,GACiB1W,gBA2BhE,SAASoZ,GAAqBvQ,EAAgBC,EAAeC,EAAiBC,EAAgB,EAAGuC,EAAgB,KAAM,IACnH,MAAM9Q,EAAS0E,OAAOoJ,OAAOwN,GAAe1f,WAI5C,OAHA+f,GAAyB3b,GAEzB0a,GAAqC1a,EADlB0E,OAAOoJ,OAAOgM,GAAgCle,WACRwS,EAAgBC,EAAeC,EAAiBC,EAAeuC,GACjH9Q,EAGX,SAASqe,GAAyBjQ,EAAgBC,EAAeC,GAC7D,MAAMtO,EAAS0E,OAAOoJ,OAAOwN,GAAe1f,WAI5C,OAHA+f,GAAyB3b,GAEzBmO,GAAkCnO,EADf0E,OAAOoJ,OAAO3E,GAA6BvN,WACRwS,EAAgBC,EAAeC,EAAiB,OAAGvR,GAClGiD,EAEX,SAAS2b,GAAyB3b,GAC9BA,EAAOG,OAAS,WAChBH,EAAOE,aAAUnD,EACjBiD,EAAOQ,kBAAezD,EACtBiD,EAAO4E,YAAa,EAExB,SAAS3B,GAAiB1H,GACtB,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,8BAGtCA,aAAa+f,GAExB,SAASvX,GAAuB/D,GAC5B,YAAuBjD,IAAnBiD,EAAOE,QAMf,SAASQ,GAAqBV,EAAQxD,GAElC,GADAwD,EAAO4E,YAAa,EACE,WAAlB5E,EAAOG,OACP,OAAO9D,OAAoBU,GAE/B,GAAsB,YAAlBiD,EAAOG,OACP,OAAO5D,EAAoByD,EAAOQ,cAEtCyM,GAAoBjN,GACpB,MAAMD,EAASC,EAAOE,QAQtB,YAPenD,IAAXgD,GAAwB6O,GAA2B7O,KACnDA,EAAOkM,kBAAkB1M,SAAQyM,IAC7BA,EAAgBtI,iBAAY3G,MAEhCgD,EAAOkM,kBAAoB,IAAI/N,GAG5BhB,EADqB8C,EAAO6E,0BAA0BxD,GAAa7E,GACzBvB,GAErD,SAASgS,GAAoBjN,GACzBA,EAAOG,OAAS,SAChB,MAAMJ,EAASC,EAAOE,aACPnD,IAAXgD,IAGJM,EAAkCN,GAC9B+D,GAA8B/D,KAC9BA,EAAOuD,cAAc/D,SAAQ8D,IACzBA,EAAYK,iBAEhB3D,EAAOuD,cAAgB,IAAIpF,IAGnC,SAAS2P,GAAoB7N,EAAQwE,GACjCxE,EAAOG,OAAS,UAChBH,EAAOQ,aAAegE,EACtB,MAAMzE,EAASC,EAAOE,aACPnD,IAAXgD,IAGJa,EAAiCb,EAAQyE,GACrCV,GAA8B/D,IAC9BA,EAAOuD,cAAc/D,SAAQ8D,IACzBA,EAAYkB,YAAYC,MAE5BzE,EAAOuD,cAAgB,IAAIpF,IAG3B6B,EAAOkM,kBAAkB1M,SAAQyM,IAC7BA,EAAgBzH,YAAYC,MAEhCzE,EAAOkM,kBAAoB,IAAI/N,IAIvC,SAAS6d,GAA4Bhb,GACjC,OAAO,IAAIjD,UAAU,4BAA4BiD,0CAGrD,SAASke,GAA2BxP,EAAMvN,GACtCF,EAAiByN,EAAMvN,GACvB,MAAMqM,EAAgBkB,MAAAA,OAAmC,EAASA,EAAKlB,cAEvE,OADA/L,EAAoB+L,EAAe,gBAAiB,uBAC7C,CACHA,cAAe7L,EAA0B6L,IA7HjD7J,OAAOI,iBAAiBwW,GAAe1f,UAAW,CAC9CsI,OAAQ,CAAEa,YAAY,GACtBiX,UAAW,CAAEjX,YAAY,GACzBoX,YAAa,CAAEpX,YAAY,GAC3ByX,OAAQ,CAAEzX,YAAY,GACtB2X,IAAK,CAAE3X,YAAY,GACnB8Z,OAAQ,CAAE9Z,YAAY,GACtBsM,OAAQ,CAAEtM,YAAY,KAEgB,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAeqW,GAAe1f,UAAWf,EAAemK,YAAa,CACxE1I,MAAO,iBACP4I,cAAc,IAGsB,iBAAjCrK,EAAeqkB,eACtBxa,OAAOO,eAAeqW,GAAe1f,UAAWf,EAAeqkB,cAAe,CAC1E5iB,MAAOgf,GAAe1f,UAAUijB,OAChC/G,UAAU,EACV5S,cAAc,IA+GtB,MAAMia,GAA0B3b,GACrBA,EAAMoE,WAEjBlD,OAAOO,eAAeka,GAAwB,OAAQ,CAClD7iB,MAAO,OACP4I,cAAc,IAOlB,MAAMka,GACFjhB,YAAY+c,GACR5Y,EAAuB4Y,EAAS,EAAG,6BACnCA,EAAU+D,GAA2B/D,EAAS,mBAC9C9c,KAAKihB,wCAA0CnE,EAAQ3M,cAKvDA,oBACA,IAAK+Q,GAA4BlhB,MAC7B,MAAMmhB,GAA8B,iBAExC,OAAOnhB,KAAKihB,wCAKZnX,WACA,IAAKoX,GAA4BlhB,MAC7B,MAAMmhB,GAA8B,QAExC,OAAOJ,IAcf,SAASI,GAA8Bxe,GACnC,OAAO,IAAIjD,UAAU,uCAAuCiD,qDAEhE,SAASue,GAA4B/jB,GACjC,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,4CAGtCA,aAAa6jB,GArBxB1a,OAAOI,iBAAiBsa,GAA0BxjB,UAAW,CACzD2S,cAAe,CAAExJ,YAAY,GAC7BmD,KAAM,CAAEnD,YAAY,KAEkB,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAema,GAA0BxjB,UAAWf,EAAemK,YAAa,CACnF1I,MAAO,4BACP4I,cAAc,IAkBtB,MAAMsa,GAAoB,IACf,EAEX9a,OAAOO,eAAeua,GAAmB,OAAQ,CAC7CljB,MAAO,OACP4I,cAAc,IAOlB,MAAMua,GACFthB,YAAY+c,GACR5Y,EAAuB4Y,EAAS,EAAG,wBACnCA,EAAU+D,GAA2B/D,EAAS,mBAC9C9c,KAAKshB,mCAAqCxE,EAAQ3M,cAKlDA,oBACA,IAAKoR,GAAuBvhB,MACxB,MAAMwhB,GAAyB,iBAEnC,OAAOxhB,KAAKshB,mCAMZxX,WACA,IAAKyX,GAAuBvhB,MACxB,MAAMwhB,GAAyB,QAEnC,OAAOJ,IAcf,SAASI,GAAyB7e,GAC9B,OAAO,IAAIjD,UAAU,kCAAkCiD,gDAE3D,SAAS4e,GAAuBpkB,GAC5B,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,uCAGtCA,aAAakkB,GAwBxB,SAASI,GAAgCpiB,EAAImS,EAAU1N,GAEnD,OADAC,EAAe1E,EAAIyE,GACXiJ,GAAelN,EAAYR,EAAImS,EAAU,CAACzE,IAEtD,SAAS2U,GAAgCriB,EAAImS,EAAU1N,GAEnD,OADAC,EAAe1E,EAAIyE,GACXiJ,GAAezN,EAAYD,EAAImS,EAAU,CAACzE,IAEtD,SAAS4U,GAAoCtiB,EAAImS,EAAU1N,GAEvD,OADAC,EAAe1E,EAAIyE,GACZ,CAACsB,EAAO2H,IAAelN,EAAYR,EAAImS,EAAU,CAACpM,EAAO2H,IAvDpEzG,OAAOI,iBAAiB2a,GAAqB7jB,UAAW,CACpD2S,cAAe,CAAExJ,YAAY,GAC7BmD,KAAM,CAAEnD,YAAY,KAEkB,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAewa,GAAqB7jB,UAAWf,EAAemK,YAAa,CAC9E1I,MAAO,uBACP4I,cAAc,IA4DtB,MAAM8a,GACF7hB,YAAY8hB,EAAiB,GAAIC,EAAsB,GAAIC,EAAsB,SACtDpjB,IAAnBkjB,IACAA,EAAiB,MAErB,MAAMG,EAAmB5Q,GAAuB0Q,EAAqB,oBAC/DG,EAAmB7Q,GAAuB2Q,EAAqB,mBAC/DG,EAlDd,SAA4B1Q,EAAU1N,GAClCF,EAAiB4N,EAAU1N,GAC3B,MAAMqe,EAAQ3Q,MAAAA,OAA2C,EAASA,EAAS2Q,MACrEC,EAAe5Q,MAAAA,OAA2C,EAASA,EAAS4Q,aAC5E/P,EAAQb,MAAAA,OAA2C,EAASA,EAASa,MACrE4L,EAAYzM,MAAAA,OAA2C,EAASA,EAASyM,UACzEoE,EAAe7Q,MAAAA,OAA2C,EAASA,EAAS6Q,aAClF,MAAO,CACHF,WAAiBxjB,IAAVwjB,OACHxjB,EACA8iB,GAAgCU,EAAO3Q,EAAU,GAAG1N,6BACxDse,aAAAA,EACA/P,WAAiB1T,IAAV0T,OACH1T,EACA+iB,GAAgCrP,EAAOb,EAAU,GAAG1N,6BACxDma,eAAyBtf,IAAdsf,OACPtf,EACAgjB,GAAoC1D,EAAWzM,EAAU,GAAG1N,iCAChEue,aAAAA,GAgCoBC,CAAmBT,EAAgB,mBACvD,QAAiCljB,IAA7BujB,EAAYE,aACZ,MAAM,IAAInY,WAAW,kCAEzB,QAAiCtL,IAA7BujB,EAAYG,aACZ,MAAM,IAAIpY,WAAW,kCAEzB,MAAMsY,EAAwBvR,GAAqBiR,EAAkB,GAC/DO,EAAwBrR,GAAqB8Q,GAC7CQ,EAAwBzR,GAAqBgR,EAAkB,GAC/DU,EAAwBvR,GAAqB6Q,GACnD,IAAIW,GA0CZ,SAAmC/gB,EAAQghB,EAAcH,EAAuBC,EAAuBH,EAAuBC,GAC1H,SAASxS,IACL,OAAO4S,EAWXhhB,EAAOihB,UAxqEX,SAA8B7S,EAAgB4C,EAAgBC,EAAgBC,EAAgB3C,EAAgB,EAAGuC,EAAgB,KAAM,IACnI,MAAM9Q,EAAS0E,OAAOoJ,OAAOsC,GAAexU,WAI5C,OAHAiV,GAAyB7Q,GAEzBmR,GAAqCnR,EADlB0E,OAAOoJ,OAAOiD,GAAgCnV,WACRwS,EAAgB4C,EAAgBC,EAAgBC,EAAgB3C,EAAeuC,GACjI9Q,EAmqEYkhB,CAAqB9S,GATxC,SAAwB5K,GACpB,OAoMR,SAAkDxD,EAAQwD,GACtD,MAAM2H,EAAanL,EAAOmhB,2BAC1B,OAAInhB,EAAOqS,cAEAnV,EAD2B8C,EAAOohB,4BACc,KACnD,MAAMtJ,EAAW9X,EAAOihB,UAExB,GAAc,aADAnJ,EAAS3X,OAEnB,MAAM2X,EAAStX,aAEnB,OAAO6gB,GAAiDlW,EAAY3H,MAGrE6d,GAAiDlW,EAAY3H,GAjNzD8d,CAAyCthB,EAAQwD,MAK5D,WACI,OAmNR,SAAkDxD,GAE9C,MAAMsc,EAAWtc,EAAOuhB,UAClBpW,EAAanL,EAAOmhB,2BACpBK,EAAerW,EAAWsW,kBAGhC,OAFAC,GAAgDvW,GAEzCjO,EAAqBskB,GAAc,KACtC,GAAwB,YAApBlF,EAASnc,OACT,MAAMmc,EAAS9b,aAEnB2Z,GAAqCmC,EAASzX,8BAC/C2J,IAEC,MADAmT,GAAqB3hB,EAAQwO,GACvB8N,EAAS9b,gBAjORohB,CAAyC5hB,MAJpD,SAAwBxD,GACpB,OAgNR,SAAkDwD,EAAQxD,GAItD,OADAmlB,GAAqB3hB,EAAQxD,GACtBH,OAAoBU,GApNhB8kB,CAAyC7hB,EAAQxD,KAK4CqkB,EAAuBC,GAQ/H9gB,EAAOuhB,UAAY5C,GAAqBvQ,GAPxC,WACI,OAiOR,SAAmDpO,GAI/C,OAFA8hB,GAA+B9hB,GAAQ,GAEhCA,EAAOohB,2BArOHW,CAA0C/hB,MAErD,SAAyBxD,GAErB,OADAwlB,GAA4ChiB,EAAQxD,GAC7CH,OAAoBU,KAEyD4jB,EAAuBC,GAE/G5gB,EAAOqS,mBAAgBtV,EACvBiD,EAAOohB,gCAA6BrkB,EACpCiD,EAAOiiB,wCAAqCllB,EAC5C+kB,GAA+B9hB,GAAQ,GACvCA,EAAOmhB,gCAA6BpkB,EAjEhCmlB,CAA0B9jB,KAHLjC,GAAWJ,IAC5BglB,EAAuBhlB,KAEmB8kB,EAAuBC,EAAuBH,EAAuBC,GAgL3H,SAA8D5gB,EAAQsgB,GAClE,MAAMnV,EAAazG,OAAOoJ,OAAOqU,GAAiCvmB,WAClE,IAAIwmB,EAAsB5e,IACtB,IAEI,OADA6e,GAAwClX,EAAY3H,GAC7CnH,OAAoBU,GAE/B,MAAOulB,GACH,OAAO/lB,EAAoB+lB,KAG/BC,EAAiB,IAAMlmB,OAAoBU,QACjBA,IAA1BujB,EAAYjE,YACZ+F,EAAqB5e,GAAS8c,EAAYjE,UAAU7Y,EAAO2H,SAErCpO,IAAtBujB,EAAYC,QACZgC,EAAiB,IAAMjC,EAAYC,MAAMpV,IAtBjD,SAA+CnL,EAAQmL,EAAYiX,EAAoBG,GACnFpX,EAAWqX,2BAA6BxiB,EACxCA,EAAOmhB,2BAA6BhW,EACpCA,EAAWsX,oBAAsBL,EACjCjX,EAAWsW,gBAAkBc,EAoB7BG,CAAsC1iB,EAAQmL,EAAYiX,EAAoBG,GAjM1EI,CAAqDvkB,KAAMkiB,QACjCvjB,IAAtBujB,EAAY7P,MACZsQ,EAAqBT,EAAY7P,MAAMrS,KAAK+iB,6BAG5CJ,OAAqBhkB,GAMzBuf,eACA,IAAKsG,GAAkBxkB,MACnB,MAAMykB,GAA0B,YAEpC,OAAOzkB,KAAKmjB,UAKZzJ,eACA,IAAK8K,GAAkBxkB,MACnB,MAAMykB,GAA0B,YAEpC,OAAOzkB,KAAK6iB,WA0CpB,SAAS2B,GAAkBrnB,GACvB,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,+BAGtCA,aAAaykB,GAGxB,SAAS2B,GAAqB3hB,EAAQwE,GAClC6V,GAAqCra,EAAOuhB,UAAU1c,0BAA2BL,GACjFwd,GAA4ChiB,EAAQwE,GAExD,SAASwd,GAA4ChiB,EAAQwE,GACzDkd,GAAgD1hB,EAAOmhB,4BACvDxL,GAA6C3V,EAAOihB,UAAUlP,0BAA2BvN,GACrFxE,EAAOqS,eAIPyP,GAA+B9hB,GAAQ,GAG/C,SAAS8hB,GAA+B9hB,EAAQ8T,QAEF/W,IAAtCiD,EAAOohB,4BACPphB,EAAOiiB,qCAEXjiB,EAAOohB,2BAA6BjlB,GAAWJ,IAC3CiE,EAAOiiB,mCAAqClmB,KAEhDiE,EAAOqS,cAAgByB,EAvE3BpP,OAAOI,iBAAiBkb,GAAgBpkB,UAAW,CAC/C0gB,SAAU,CAAEvX,YAAY,GACxB+S,SAAU,CAAE/S,YAAY,KAEc,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAe+a,GAAgBpkB,UAAWf,EAAemK,YAAa,CACzE1I,MAAO,kBACP4I,cAAc,IAwEtB,MAAMid,GACFhkB,cACI,MAAM,IAAIL,UAAU,uBAKpB0L,kBACA,IAAKsZ,GAAmC1kB,MACpC,MAAM2kB,GAAqC,eAG/C,OAAO9I,GADoB7b,KAAKokB,2BAA2BjB,UAAU1c,2BAGzEkF,QAAQvG,GACJ,IAAKsf,GAAmC1kB,MACpC,MAAM2kB,GAAqC,WAE/CV,GAAwCjkB,KAAMoF,GAMlDyG,MAAMzN,GACF,IAAKsmB,GAAmC1kB,MACpC,MAAM2kB,GAAqC,SAwFvD,IAA2Dve,EAAAA,EAtFPhI,EAuFhDmlB,GAvF0CvjB,KAuFVokB,2BAA4Bhe,GAjF5Dwe,YACI,IAAKF,GAAmC1kB,MACpC,MAAM2kB,GAAqC,cAwFvD,SAAmD5X,GAC/C,MAAMnL,EAASmL,EAAWqX,2BAE1BrI,GAD2Bna,EAAOuhB,UAAU1c,2BAG5Cmd,GAA4ChiB,EAD9B,IAAIlC,UAAU,+BA1FxBmlB,CAA0C7kB,OAgBlD,SAAS0kB,GAAmCvnB,GACxC,QAAKD,EAAaC,MAGbmJ,OAAO9I,UAAU+I,eAAe9H,KAAKtB,EAAG,+BAGtCA,aAAa4mB,GA4BxB,SAAST,GAAgDvW,GACrDA,EAAWsX,yBAAsB1lB,EACjCoO,EAAWsW,qBAAkB1kB,EAEjC,SAASslB,GAAwClX,EAAY3H,GACzD,MAAMxD,EAASmL,EAAWqX,2BACpBU,EAAqBljB,EAAOuhB,UAAU1c,0BAC5C,IAAKqV,GAAiDgJ,GAClD,MAAM,IAAIplB,UAAU,wDAIxB,IACIsc,GAAuC8I,EAAoB1f,GAE/D,MAAOgB,GAGH,MADAwd,GAA4ChiB,EAAQwE,GAC9CxE,EAAOuhB,UAAU/gB,aAE3B,MAAMsT,EA/nCV,SAAwD3I,GACpD,OAAIsP,GAA8CtP,GA8nC7BgY,CAA+CD,GAChEpP,IAAiB9T,EAAOqS,eACxByP,GAA+B9hB,GAAQ,GAM/C,SAASqhB,GAAiDlW,EAAY3H,GAElE,OAAOtG,EADkBiO,EAAWsX,oBAAoBjf,QACVzG,GAAWyR,IAErD,MADAmT,GAAqBxW,EAAWqX,2BAA4BhU,GACtDA,KAyDd,SAASuU,GAAqChiB,GAC1C,OAAO,IAAIjD,UAAU,8CAA8CiD,4DAGvE,SAAS8hB,GAA0B9hB,GAC/B,OAAO,IAAIjD,UAAU,6BAA6BiD,2CA9ItD2D,OAAOI,iBAAiBqd,GAAiCvmB,UAAW,CAChEmO,QAAS,CAAEhF,YAAY,GACvBkF,MAAO,CAAElF,YAAY,GACrBie,UAAW,CAAEje,YAAY,GACzByE,YAAa,CAAEzE,YAAY,KAEW,iBAA/BlK,EAAemK,aACtBN,OAAOO,eAAekd,GAAiCvmB,UAAWf,EAAemK,YAAa,CAC1F1I,MAAO,mCACP4I,cAAc","sources":["webpack://screen-recorder/./node_modules/web-streams-polyfill/dist/ponyfill.es2018.mjs"],"sourcesContent":["/**\n * web-streams-polyfill v3.2.0\n */\n/// <reference lib=\"es2015.symbol\" />\nconst SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})`;\n\n/// <reference lib=\"dom\" />\nfunction noop() {\n    return undefined;\n}\nfunction getGlobals() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    else if (typeof window !== 'undefined') {\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        return global;\n    }\n    return undefined;\n}\nconst globals = getGlobals();\n\nfunction typeIsObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nconst rethrowAssertionErrorRejection = noop;\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\nfunction newPromise(executor) {\n    return new originalPromise(executor);\n}\nfunction promiseResolvedWith(value) {\n    return originalPromiseResolve(value);\n}\nfunction promiseRejectedWith(reason) {\n    return originalPromiseReject(reason);\n}\nfunction PerformPromiseThen(promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return originalPromiseThen.call(promise, onFulfilled, onRejected);\n}\nfunction uponPromise(promise, onFulfilled, onRejected) {\n    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n}\nfunction uponFulfillment(promise, onFulfilled) {\n    uponPromise(promise, onFulfilled);\n}\nfunction uponRejection(promise, onRejected) {\n    uponPromise(promise, undefined, onRejected);\n}\nfunction transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\nfunction setPromiseIsHandledToTrue(promise) {\n    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\nconst queueMicrotask = (() => {\n    const globalQueueMicrotask = globals && globals.queueMicrotask;\n    if (typeof globalQueueMicrotask === 'function') {\n        return globalQueueMicrotask;\n    }\n    const resolvedPromise = promiseResolvedWith(undefined);\n    return (fn) => PerformPromiseThen(resolvedPromise, fn);\n})();\nfunction reflectCall(F, V, args) {\n    if (typeof F !== 'function') {\n        throw new TypeError('Argument is not a function');\n    }\n    return Function.prototype.apply.call(F, V, args);\n}\nfunction promiseCall(F, V, args) {\n    try {\n        return promiseResolvedWith(reflectCall(F, V, args));\n    }\n    catch (value) {\n        return promiseRejectedWith(value);\n    }\n}\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nclass SimpleQueue {\n    constructor() {\n        this._cursor = 0;\n        this._size = 0;\n        // _front and _back are always defined.\n        this._front = {\n            _elements: [],\n            _next: undefined\n        };\n        this._back = this._front;\n        // The cursor is used to avoid calling Array.shift().\n        // It contains the index of the front element of the array inside the\n        // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n        this._cursor = 0;\n        // When there is only one node, size === elements.length - cursor.\n        this._size = 0;\n    }\n    get length() {\n        return this._size;\n    }\n    // For exception safety, this method is structured in order:\n    // 1. Read state\n    // 2. Calculate required state mutations\n    // 3. Perform state mutations\n    push(element) {\n        const oldBack = this._back;\n        let newBack = oldBack;\n        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n            newBack = {\n                _elements: [],\n                _next: undefined\n            };\n        }\n        // push() is the mutation most likely to throw an exception, so it\n        // goes first.\n        oldBack._elements.push(element);\n        if (newBack !== oldBack) {\n            this._back = newBack;\n            oldBack._next = newBack;\n        }\n        ++this._size;\n    }\n    // Like push(), shift() follows the read -> calculate -> mutate pattern for\n    // exception safety.\n    shift() { // must not be called on an empty queue\n        const oldFront = this._front;\n        let newFront = oldFront;\n        const oldCursor = this._cursor;\n        let newCursor = oldCursor + 1;\n        const elements = oldFront._elements;\n        const element = elements[oldCursor];\n        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n            newFront = oldFront._next;\n            newCursor = 0;\n        }\n        // No mutations before this point.\n        --this._size;\n        this._cursor = newCursor;\n        if (oldFront !== newFront) {\n            this._front = newFront;\n        }\n        // Permit shifted element to be garbage collected.\n        elements[oldCursor] = undefined;\n        return element;\n    }\n    // The tricky thing about forEach() is that it can be called\n    // re-entrantly. The queue may be mutated inside the callback. It is easy to\n    // see that push() within the callback has no negative effects since the end\n    // of the queue is checked for on every iteration. If shift() is called\n    // repeatedly within the callback then the next iteration may return an\n    // element that has been removed. In this case the callback will be called\n    // with undefined values until we either \"catch up\" with elements that still\n    // exist or reach the back of the queue.\n    forEach(callback) {\n        let i = this._cursor;\n        let node = this._front;\n        let elements = node._elements;\n        while (i !== elements.length || node._next !== undefined) {\n            if (i === elements.length) {\n                node = node._next;\n                elements = node._elements;\n                i = 0;\n                if (elements.length === 0) {\n                    break;\n                }\n            }\n            callback(elements[i]);\n            ++i;\n        }\n    }\n    // Return the element that would be returned if shift() was called now,\n    // without modifying the queue.\n    peek() { // must not be called on an empty queue\n        const front = this._front;\n        const cursor = this._cursor;\n        return front._elements[cursor];\n    }\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n    reader._ownerReadableStream = stream;\n    stream._reader = reader;\n    if (stream._state === 'readable') {\n        defaultReaderClosedPromiseInitialize(reader);\n    }\n    else if (stream._state === 'closed') {\n        defaultReaderClosedPromiseInitializeAsResolved(reader);\n    }\n    else {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    }\n}\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n    const stream = reader._ownerReadableStream;\n    return ReadableStreamCancel(stream, reason);\n}\nfunction ReadableStreamReaderGenericRelease(reader) {\n    if (reader._ownerReadableStream._state === 'readable') {\n        defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    else {\n        defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    reader._ownerReadableStream._reader = undefined;\n    reader._ownerReadableStream = undefined;\n}\n// Helper functions for the readers.\nfunction readerLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderClosedPromiseInitialize(reader) {\n    reader._closedPromise = newPromise((resolve, reject) => {\n        reader._closedPromise_resolve = resolve;\n        reader._closedPromise_reject = reject;\n    });\n}\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseReject(reader, reason);\n}\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n    if (reader._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(reader._closedPromise);\n    reader._closedPromise_reject(reason);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\nfunction defaultReaderClosedPromiseResolve(reader) {\n    if (reader._closedPromise_resolve === undefined) {\n        return;\n    }\n    reader._closedPromise_resolve(undefined);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\n\nconst AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nconst ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\nconst CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nconst PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite = Number.isFinite || function (x) {\n    return typeof x === 'number' && isFinite(x);\n};\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc = Math.trunc || function (v) {\n    return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nfunction isDictionary(x) {\n    return typeof x === 'object' || typeof x === 'function';\n}\nfunction assertDictionary(obj, context) {\n    if (obj !== undefined && !isDictionary(obj)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-callback-functions\nfunction assertFunction(x, context) {\n    if (typeof x !== 'function') {\n        throw new TypeError(`${context} is not a function.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-object\nfunction isObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nfunction assertObject(x, context) {\n    if (!isObject(x)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\nfunction assertRequiredArgument(x, position, context) {\n    if (x === undefined) {\n        throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n    }\n}\nfunction assertRequiredField(x, field, context) {\n    if (x === undefined) {\n        throw new TypeError(`${field} is required in '${context}'.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nfunction convertUnrestrictedDouble(value) {\n    return Number(value);\n}\nfunction censorNegativeZero(x) {\n    return x === 0 ? 0 : x;\n}\nfunction integerPart(x) {\n    return censorNegativeZero(MathTrunc(x));\n}\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nfunction convertUnsignedLongLongWithEnforceRange(value, context) {\n    const lowerBound = 0;\n    const upperBound = Number.MAX_SAFE_INTEGER;\n    let x = Number(value);\n    x = censorNegativeZero(x);\n    if (!NumberIsFinite(x)) {\n        throw new TypeError(`${context} is not a finite number`);\n    }\n    x = integerPart(x);\n    if (x < lowerBound || x > upperBound) {\n        throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n    }\n    if (!NumberIsFinite(x) || x === 0) {\n        return 0;\n    }\n    // TODO Use BigInt if supported?\n    // let xBigInt = BigInt(integerPart(x));\n    // xBigInt = BigInt.asUintN(64, xBigInt);\n    // return Number(xBigInt);\n    return x;\n}\n\nfunction assertReadableStream(x, context) {\n    if (!IsReadableStream(x)) {\n        throw new TypeError(`${context} is not a ReadableStream.`);\n    }\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamDefaultReader(stream) {\n    return new ReadableStreamDefaultReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadRequest(stream, readRequest) {\n    stream._reader._readRequests.push(readRequest);\n}\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readRequest = reader._readRequests.shift();\n    if (done) {\n        readRequest._closeSteps();\n    }\n    else {\n        readRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadRequests(stream) {\n    return stream._reader._readRequests.length;\n}\nfunction ReadableStreamHasDefaultReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamDefaultReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamDefaultReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed,\n     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamDefaultReaderRead(this, readRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            throw defaultReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamDefaultReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n        return false;\n    }\n    return x instanceof ReadableStreamDefaultReader;\n}\nfunction ReadableStreamDefaultReaderRead(reader, readRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        readRequest._closeSteps();\n    }\n    else if (stream._state === 'errored') {\n        readRequest._errorSteps(stream._storedError);\n    }\n    else {\n        stream._readableStreamController[PullSteps](readRequest);\n    }\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\n/* eslint-disable @typescript-eslint/no-empty-function */\nconst AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);\n\n/// <reference lib=\"es2018.asynciterable\" />\nclass ReadableStreamAsyncIteratorImpl {\n    constructor(reader, preventCancel) {\n        this._ongoingPromise = undefined;\n        this._isFinished = false;\n        this._reader = reader;\n        this._preventCancel = preventCancel;\n    }\n    next() {\n        const nextSteps = () => this._nextSteps();\n        this._ongoingPromise = this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n            nextSteps();\n        return this._ongoingPromise;\n    }\n    return(value) {\n        const returnSteps = () => this._returnSteps(value);\n        return this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n            returnSteps();\n    }\n    _nextSteps() {\n        if (this._isFinished) {\n            return Promise.resolve({ value: undefined, done: true });\n        }\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('iterate'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => {\n                this._ongoingPromise = undefined;\n                // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                // FIXME Is this a bug in the specification, or in the test?\n                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n            },\n            _closeSteps: () => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                resolvePromise({ value: undefined, done: true });\n            },\n            _errorSteps: reason => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                rejectPromise(reason);\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promise;\n    }\n    _returnSteps(value) {\n        if (this._isFinished) {\n            return Promise.resolve({ value, done: true });\n        }\n        this._isFinished = true;\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('finish iterating'));\n        }\n        if (!this._preventCancel) {\n            const result = ReadableStreamReaderGenericCancel(reader, value);\n            ReadableStreamReaderGenericRelease(reader);\n            return transformPromiseWith(result, () => ({ value, done: true }));\n        }\n        ReadableStreamReaderGenericRelease(reader);\n        return promiseResolvedWith({ value, done: true });\n    }\n}\nconst ReadableStreamAsyncIteratorPrototype = {\n    next() {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        return this._asyncIteratorImpl.next();\n    },\n    return(value) {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n        }\n        return this._asyncIteratorImpl.return(value);\n    }\n};\nif (AsyncIteratorPrototype !== undefined) {\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n    iterator._asyncIteratorImpl = impl;\n    return iterator;\n}\nfunction IsReadableStreamAsyncIterator(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n        return false;\n    }\n    try {\n        // noinspection SuspiciousTypeOfGuard\n        return x._asyncIteratorImpl instanceof\n            ReadableStreamAsyncIteratorImpl;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n// Helper functions for the ReadableStream.\nfunction streamAsyncIteratorBrandCheckException(name) {\n    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n};\n\nfunction CreateArrayFromList(elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n}\nfunction CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n// Not implemented correctly\nfunction TransferArrayBuffer(O) {\n    return O;\n}\n// Not implemented correctly\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction IsDetachedBuffer(O) {\n    return false;\n}\nfunction ArrayBufferSlice(buffer, begin, end) {\n    // ArrayBuffer.prototype.slice is not available on IE10\n    // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n    if (buffer.slice) {\n        return buffer.slice(begin, end);\n    }\n    const length = end - begin;\n    const slice = new ArrayBuffer(length);\n    CopyDataBlockBytes(slice, 0, buffer, begin, length);\n    return slice;\n}\n\nfunction IsNonNegativeNumber(v) {\n    if (typeof v !== 'number') {\n        return false;\n    }\n    if (NumberIsNaN(v)) {\n        return false;\n    }\n    if (v < 0) {\n        return false;\n    }\n    return true;\n}\nfunction CloneAsUint8Array(O) {\n    const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n    return new Uint8Array(buffer);\n}\n\nfunction DequeueValue(container) {\n    const pair = container._queue.shift();\n    container._queueTotalSize -= pair.size;\n    if (container._queueTotalSize < 0) {\n        container._queueTotalSize = 0;\n    }\n    return pair.value;\n}\nfunction EnqueueValueWithSize(container, value, size) {\n    if (!IsNonNegativeNumber(size) || size === Infinity) {\n        throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n    }\n    container._queue.push({ value, size });\n    container._queueTotalSize += size;\n}\nfunction PeekQueueValue(container) {\n    const pair = container._queue.peek();\n    return pair.value;\n}\nfunction ResetQueue(container) {\n    container._queue = new SimpleQueue();\n    container._queueTotalSize = 0;\n}\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nclass ReadableStreamBYOBRequest {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n     */\n    get view() {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('view');\n        }\n        return this._view;\n    }\n    respond(bytesWritten) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        assertRequiredArgument(bytesWritten, 1, 'respond');\n        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(this._view.buffer)) ;\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n    }\n    respondWithNewView(view) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respondWithNewView');\n        }\n        assertRequiredArgument(view, 1, 'respondWithNewView');\n        if (!ArrayBuffer.isView(view)) {\n            throw new TypeError('You can only respond with array buffer views');\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(view.buffer)) ;\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n    respond: { enumerable: true },\n    respondWithNewView: { enumerable: true },\n    view: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBRequest',\n        configurable: true\n    });\n}\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableByteStreamController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the current BYOB pull request, or `null` if there isn't one.\n     */\n    get byobRequest() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('byobRequest');\n        }\n        return ReadableByteStreamControllerGetBYOBRequest(this);\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('desiredSize');\n        }\n        return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('close');\n        }\n        if (this._closeRequested) {\n            throw new TypeError('The stream has already been closed; do not close it again!');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n        }\n        ReadableByteStreamControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('enqueue');\n        }\n        assertRequiredArgument(chunk, 1, 'enqueue');\n        if (!ArrayBuffer.isView(chunk)) {\n            throw new TypeError('chunk must be an array buffer view');\n        }\n        if (chunk.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (chunk.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._closeRequested) {\n            throw new TypeError('stream is closed or draining');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n        }\n        ReadableByteStreamControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('error');\n        }\n        ReadableByteStreamControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ReadableByteStreamControllerClearPendingPullIntos(this);\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableByteStreamControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableByteStream;\n        if (this._queueTotalSize > 0) {\n            const entry = this._queue.shift();\n            this._queueTotalSize -= entry.byteLength;\n            ReadableByteStreamControllerHandleQueueDrain(this);\n            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n            readRequest._chunkSteps(view);\n            return;\n        }\n        const autoAllocateChunkSize = this._autoAllocateChunkSize;\n        if (autoAllocateChunkSize !== undefined) {\n            let buffer;\n            try {\n                buffer = new ArrayBuffer(autoAllocateChunkSize);\n            }\n            catch (bufferE) {\n                readRequest._errorSteps(bufferE);\n                return;\n            }\n            const pullIntoDescriptor = {\n                buffer,\n                bufferByteLength: autoAllocateChunkSize,\n                byteOffset: 0,\n                byteLength: autoAllocateChunkSize,\n                bytesFilled: 0,\n                elementSize: 1,\n                viewConstructor: Uint8Array,\n                readerType: 'default'\n            };\n            this._pendingPullIntos.push(pullIntoDescriptor);\n        }\n        ReadableStreamAddReadRequest(stream, readRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(this);\n    }\n}\nObject.defineProperties(ReadableByteStreamController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    byobRequest: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableByteStreamController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableByteStreamController.\nfunction IsReadableByteStreamController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n        return false;\n    }\n    return x instanceof ReadableByteStreamController;\n}\nfunction IsReadableStreamBYOBRequest(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n        return false;\n    }\n    return x instanceof ReadableStreamBYOBRequest;\n}\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    // TODO: Test controller argument\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableByteStreamControllerError(controller, e);\n    });\n}\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    controller._pendingPullIntos = new SimpleQueue();\n}\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n    let done = false;\n    if (stream._state === 'closed') {\n        done = true;\n    }\n    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    if (pullIntoDescriptor.readerType === 'default') {\n        ReadableStreamFulfillReadRequest(stream, filledView, done);\n    }\n    else {\n        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n    }\n}\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n    const bytesFilled = pullIntoDescriptor.bytesFilled;\n    const elementSize = pullIntoDescriptor.elementSize;\n    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n    controller._queue.push({ buffer, byteOffset, byteLength });\n    controller._queueTotalSize += byteLength;\n}\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n    const elementSize = pullIntoDescriptor.elementSize;\n    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n    let totalBytesToCopyRemaining = maxBytesToCopy;\n    let ready = false;\n    if (maxAlignedBytes > currentAlignedBytes) {\n        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n        ready = true;\n    }\n    const queue = controller._queue;\n    while (totalBytesToCopyRemaining > 0) {\n        const headOfQueue = queue.peek();\n        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n        if (headOfQueue.byteLength === bytesToCopy) {\n            queue.shift();\n        }\n        else {\n            headOfQueue.byteOffset += bytesToCopy;\n            headOfQueue.byteLength -= bytesToCopy;\n        }\n        controller._queueTotalSize -= bytesToCopy;\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n        totalBytesToCopyRemaining -= bytesToCopy;\n    }\n    return ready;\n}\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n    pullIntoDescriptor.bytesFilled += size;\n}\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n    if (controller._queueTotalSize === 0 && controller._closeRequested) {\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(controller._controlledReadableByteStream);\n    }\n    else {\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n}\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n    if (controller._byobRequest === null) {\n        return;\n    }\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\n    controller._byobRequest._view = null;\n    controller._byobRequest = null;\n}\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n    while (controller._pendingPullIntos.length > 0) {\n        if (controller._queueTotalSize === 0) {\n            return;\n        }\n        const pullIntoDescriptor = controller._pendingPullIntos.peek();\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n    const stream = controller._controlledReadableByteStream;\n    let elementSize = 1;\n    if (view.constructor !== DataView) {\n        elementSize = view.constructor.BYTES_PER_ELEMENT;\n    }\n    const ctor = view.constructor;\n    // try {\n    const buffer = TransferArrayBuffer(view.buffer);\n    // } catch (e) {\n    //   readIntoRequest._errorSteps(e);\n    //   return;\n    // }\n    const pullIntoDescriptor = {\n        buffer,\n        bufferByteLength: buffer.byteLength,\n        byteOffset: view.byteOffset,\n        byteLength: view.byteLength,\n        bytesFilled: 0,\n        elementSize,\n        viewConstructor: ctor,\n        readerType: 'byob'\n    };\n    if (controller._pendingPullIntos.length > 0) {\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n        // - No change happens on desiredSize\n        // - The source has already been notified of that there's at least 1 pending read(view)\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        return;\n    }\n    if (stream._state === 'closed') {\n        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n        readIntoRequest._closeSteps(emptyView);\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            ReadableByteStreamControllerHandleQueueDrain(controller);\n            readIntoRequest._chunkSteps(filledView);\n            return;\n        }\n        if (controller._closeRequested) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            readIntoRequest._errorSteps(e);\n            return;\n        }\n    }\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n    const stream = controller._controlledReadableByteStream;\n    if (ReadableStreamHasBYOBReader(stream)) {\n        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n        return;\n    }\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n    if (remainderSize > 0) {\n        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n    }\n    pullIntoDescriptor.bytesFilled -= remainderSize;\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        ReadableByteStreamControllerRespondInClosedState(controller);\n    }\n    else {\n        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n    const descriptor = controller._pendingPullIntos.shift();\n    return descriptor;\n}\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return false;\n    }\n    if (controller._closeRequested) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n}\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\nfunction ReadableByteStreamControllerClose(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        controller._closeRequested = true;\n        return;\n    }\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (firstPendingPullInto.bytesFilled > 0) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            throw e;\n        }\n    }\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n}\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    const buffer = chunk.buffer;\n    const byteOffset = chunk.byteOffset;\n    const byteLength = chunk.byteLength;\n    const transferredBuffer = TransferArrayBuffer(buffer);\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n        firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n    }\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    if (ReadableStreamHasDefaultReader(stream)) {\n        if (ReadableStreamGetNumReadRequests(stream) === 0) {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        else {\n            if (controller._pendingPullIntos.length > 0) {\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n            }\n            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, false);\n        }\n    }\n    else if (ReadableStreamHasBYOBReader(stream)) {\n        // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    else {\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerError(controller, e) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\n    ResetQueue(controller);\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableByteStreamControllerGetBYOBRequest(controller) {\n    if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n        const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n        SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n        controller._byobRequest = byobRequest;\n    }\n    return controller._byobRequest;\n}\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        if (bytesWritten !== 0) {\n            throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n        }\n    }\n    else {\n        if (bytesWritten === 0) {\n            throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n        }\n        if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n            throw new RangeError('bytesWritten out of range');\n        }\n    }\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        if (view.byteLength !== 0) {\n            throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n        }\n    }\n    else {\n        if (view.byteLength === 0) {\n            throw new TypeError('The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');\n        }\n    }\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n        throw new RangeError('The region specified by view does not match byobRequest');\n    }\n    if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n        throw new RangeError('The buffer of view has different capacity than byobRequest');\n    }\n    if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n        throw new RangeError('The region specified by view is larger than byobRequest');\n    }\n    const viewByteLength = view.byteLength;\n    firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n    ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n}\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n    controller._controlledReadableByteStream = stream;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._byobRequest = null;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._closeRequested = false;\n    controller._started = false;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    controller._autoAllocateChunkSize = autoAllocateChunkSize;\n    controller._pendingPullIntos = new SimpleQueue();\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableByteStreamControllerError(controller, r);\n    });\n}\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingByteSource.start !== undefined) {\n        startAlgorithm = () => underlyingByteSource.start(controller);\n    }\n    if (underlyingByteSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingByteSource.pull(controller);\n    }\n    if (underlyingByteSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingByteSource.cancel(reason);\n    }\n    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n    if (autoAllocateChunkSize === 0) {\n        throw new TypeError('autoAllocateChunkSize must be greater than 0');\n    }\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n    request._associatedReadableByteStreamController = controller;\n    request._view = view;\n}\n// Helper functions for the ReadableStreamBYOBRequest.\nfunction byobRequestBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n// Helper functions for the ReadableByteStreamController.\nfunction byteStreamControllerBrandCheckException(name) {\n    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamBYOBReader(stream) {\n    return new ReadableStreamBYOBReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n    stream._reader._readIntoRequests.push(readIntoRequest);\n}\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readIntoRequest = reader._readIntoRequests.shift();\n    if (done) {\n        readIntoRequest._closeSteps(chunk);\n    }\n    else {\n        readIntoRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n    return stream._reader._readIntoRequests.length;\n}\nfunction ReadableStreamHasBYOBReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamBYOBReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamBYOBReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        if (!IsReadableByteStreamController(stream._readableStreamController)) {\n            throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                'source');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readIntoRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Attempts to reads bytes into view, and returns a promise resolved with the result.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read(view) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('read'));\n        }\n        if (!ArrayBuffer.isView(view)) {\n            return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n        }\n        if (view.byteLength === 0) {\n            return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n        }\n        if (view.buffer.byteLength === 0) {\n            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n        }\n        if (IsDetachedBuffer(view.buffer)) ;\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readIntoRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            throw byobReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readIntoRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamBYOBReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n        return false;\n    }\n    return x instanceof ReadableStreamBYOBReader;\n}\nfunction ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'errored') {\n        readIntoRequest._errorSteps(stream._storedError);\n    }\n    else {\n        ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n    }\n}\n// Helper functions for the ReadableStreamBYOBReader.\nfunction byobReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\nfunction ExtractHighWaterMark(strategy, defaultHWM) {\n    const { highWaterMark } = strategy;\n    if (highWaterMark === undefined) {\n        return defaultHWM;\n    }\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n        throw new RangeError('Invalid highWaterMark');\n    }\n    return highWaterMark;\n}\nfunction ExtractSizeAlgorithm(strategy) {\n    const { size } = strategy;\n    if (!size) {\n        return () => 1;\n    }\n    return size;\n}\n\nfunction convertQueuingStrategy(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    const size = init === null || init === void 0 ? void 0 : init.size;\n    return {\n        highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n        size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n    };\n}\nfunction convertQueuingStrategySize(fn, context) {\n    assertFunction(fn, context);\n    return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n\nfunction convertUnderlyingSink(original, context) {\n    assertDictionary(original, context);\n    const abort = original === null || original === void 0 ? void 0 : original.abort;\n    const close = original === null || original === void 0 ? void 0 : original.close;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    const write = original === null || original === void 0 ? void 0 : original.write;\n    return {\n        abort: abort === undefined ?\n            undefined :\n            convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n        close: close === undefined ?\n            undefined :\n            convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n        write: write === undefined ?\n            undefined :\n            convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n        type\n    };\n}\nfunction convertUnderlyingSinkAbortCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSinkCloseCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return () => promiseCall(fn, original, []);\n}\nfunction convertUnderlyingSinkStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSinkWriteCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction assertWritableStream(x, context) {\n    if (!IsWritableStream(x)) {\n        throw new TypeError(`${context} is not a WritableStream.`);\n    }\n}\n\nfunction isAbortSignal(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        return typeof value.aborted === 'boolean';\n    }\n    catch (_a) {\n        // AbortSignal.prototype.aborted throws if its brand check fails\n        return false;\n    }\n}\nconst supportsAbortController = typeof AbortController === 'function';\n/**\n * Construct a new AbortController, if supported by the platform.\n *\n * @internal\n */\nfunction createAbortController() {\n    if (supportsAbortController) {\n        return new AbortController();\n    }\n    return undefined;\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream {\n    constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n        if (rawUnderlyingSink === undefined) {\n            rawUnderlyingSink = null;\n        }\n        else {\n            assertObject(rawUnderlyingSink, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n        InitializeWritableStream(this);\n        const type = underlyingSink.type;\n        if (type !== undefined) {\n            throw new RangeError('Invalid type is specified');\n        }\n        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n        const highWaterMark = ExtractHighWaterMark(strategy, 1);\n        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n    }\n    /**\n     * Returns whether or not the writable stream is locked to a writer.\n     */\n    get locked() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('locked');\n        }\n        return IsWritableStreamLocked(this);\n    }\n    /**\n     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n     * mechanism of the underlying sink.\n     *\n     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n     * the stream) if the stream is currently locked.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('abort'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n        }\n        return WritableStreamAbort(this, reason);\n    }\n    /**\n     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n     * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n     *\n     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n     */\n    close() {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('close'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamClose(this);\n    }\n    /**\n     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n     * is locked, no other writer can be acquired until this one is released.\n     *\n     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n     */\n    getWriter() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('getWriter');\n        }\n        return AcquireWritableStreamDefaultWriter(this);\n    }\n}\nObject.defineProperties(WritableStream.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    getWriter: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStream',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStream.\nfunction AcquireWritableStreamDefaultWriter(stream) {\n    return new WritableStreamDefaultWriter(stream);\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(WritableStream.prototype);\n    InitializeWritableStream(stream);\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeWritableStream(stream) {\n    stream._state = 'writable';\n    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n    // 'erroring' or 'errored'. May be set to an undefined value.\n    stream._storedError = undefined;\n    stream._writer = undefined;\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    stream._writableStreamController = undefined;\n    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n    stream._writeRequests = new SimpleQueue();\n    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n    stream._inFlightWriteRequest = undefined;\n    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n    stream._closeRequest = undefined;\n    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n    stream._inFlightCloseRequest = undefined;\n    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n    stream._pendingAbortRequest = undefined;\n    // The backpressure signal set by the controller.\n    stream._backpressure = false;\n}\nfunction IsWritableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n        return false;\n    }\n    return x instanceof WritableStream;\n}\nfunction IsWritableStreamLocked(stream) {\n    if (stream._writer === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamAbort(stream, reason) {\n    var _a;\n    if (stream._state === 'closed' || stream._state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    stream._writableStreamController._abortReason = reason;\n    (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n    // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n    // but it doesn't know that signaling abort runs author code that might have changed the state.\n    // Widen the type again by casting to WritableStreamState.\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._pendingAbortRequest !== undefined) {\n        return stream._pendingAbortRequest._promise;\n    }\n    let wasAlreadyErroring = false;\n    if (state === 'erroring') {\n        wasAlreadyErroring = true;\n        // reason will not be used, so don't keep a reference to it.\n        reason = undefined;\n    }\n    const promise = newPromise((resolve, reject) => {\n        stream._pendingAbortRequest = {\n            _promise: undefined,\n            _resolve: resolve,\n            _reject: reject,\n            _reason: reason,\n            _wasAlreadyErroring: wasAlreadyErroring\n        };\n    });\n    stream._pendingAbortRequest._promise = promise;\n    if (!wasAlreadyErroring) {\n        WritableStreamStartErroring(stream, reason);\n    }\n    return promise;\n}\nfunction WritableStreamClose(stream) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n    }\n    const promise = newPromise((resolve, reject) => {\n        const closeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._closeRequest = closeRequest;\n    });\n    const writer = stream._writer;\n    if (writer !== undefined && stream._backpressure && state === 'writable') {\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\n    return promise;\n}\n// WritableStream API exposed for controllers.\nfunction WritableStreamAddWriteRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const writeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._writeRequests.push(writeRequest);\n    });\n    return promise;\n}\nfunction WritableStreamDealWithRejection(stream, error) {\n    const state = stream._state;\n    if (state === 'writable') {\n        WritableStreamStartErroring(stream, error);\n        return;\n    }\n    WritableStreamFinishErroring(stream);\n}\nfunction WritableStreamStartErroring(stream, reason) {\n    const controller = stream._writableStreamController;\n    stream._state = 'erroring';\n    stream._storedError = reason;\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n    }\n    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n        WritableStreamFinishErroring(stream);\n    }\n}\nfunction WritableStreamFinishErroring(stream) {\n    stream._state = 'errored';\n    stream._writableStreamController[ErrorSteps]();\n    const storedError = stream._storedError;\n    stream._writeRequests.forEach(writeRequest => {\n        writeRequest._reject(storedError);\n    });\n    stream._writeRequests = new SimpleQueue();\n    if (stream._pendingAbortRequest === undefined) {\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const abortRequest = stream._pendingAbortRequest;\n    stream._pendingAbortRequest = undefined;\n    if (abortRequest._wasAlreadyErroring) {\n        abortRequest._reject(storedError);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n    uponPromise(promise, () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }, (reason) => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\nfunction WritableStreamFinishInFlightWrite(stream) {\n    stream._inFlightWriteRequest._resolve(undefined);\n    stream._inFlightWriteRequest = undefined;\n}\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n    stream._inFlightWriteRequest._reject(error);\n    stream._inFlightWriteRequest = undefined;\n    WritableStreamDealWithRejection(stream, error);\n}\nfunction WritableStreamFinishInFlightClose(stream) {\n    stream._inFlightCloseRequest._resolve(undefined);\n    stream._inFlightCloseRequest = undefined;\n    const state = stream._state;\n    if (state === 'erroring') {\n        // The error was too late to do anything, so it is ignored.\n        stream._storedError = undefined;\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._resolve();\n            stream._pendingAbortRequest = undefined;\n        }\n    }\n    stream._state = 'closed';\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseResolve(writer);\n    }\n}\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n    stream._inFlightCloseRequest._reject(error);\n    stream._inFlightCloseRequest = undefined;\n    // Never execute sink abort() after sink close().\n    if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(error);\n        stream._pendingAbortRequest = undefined;\n    }\n    WritableStreamDealWithRejection(stream, error);\n}\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n    stream._inFlightCloseRequest = stream._closeRequest;\n    stream._closeRequest = undefined;\n}\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n    if (stream._closeRequest !== undefined) {\n        stream._closeRequest._reject(stream._storedError);\n        stream._closeRequest = undefined;\n    }\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseReject(writer, stream._storedError);\n    }\n}\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n    const writer = stream._writer;\n    if (writer !== undefined && backpressure !== stream._backpressure) {\n        if (backpressure) {\n            defaultWriterReadyPromiseReset(writer);\n        }\n        else {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n    }\n    stream._backpressure = backpressure;\n}\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nclass WritableStreamDefaultWriter {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n        assertWritableStream(stream, 'First parameter');\n        if (IsWritableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n        }\n        this._ownerWritableStream = stream;\n        stream._writer = this;\n        const state = stream._state;\n        if (state === 'writable') {\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                defaultWriterReadyPromiseInitialize(this);\n            }\n            else {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n            }\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'erroring') {\n            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'closed') {\n            defaultWriterReadyPromiseInitializeAsResolved(this);\n            defaultWriterClosedPromiseInitializeAsResolved(this);\n        }\n        else {\n            const storedError = stream._storedError;\n            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n        }\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the writers lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n     * A producer can use this information to determine the right amount of data to write.\n     *\n     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n     * the writers lock is released.\n     */\n    get desiredSize() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('desiredSize');\n        }\n        if (this._ownerWritableStream === undefined) {\n            throw defaultWriterLockException('desiredSize');\n        }\n        return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n    /**\n     * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n     * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n     *\n     * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n     * rejected.\n     */\n    get ready() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n        }\n        return this._readyPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('abort'));\n        }\n        return WritableStreamDefaultWriterAbort(this, reason);\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n     */\n    close() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('close'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamDefaultWriterClose(this);\n    }\n    /**\n     * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n     * now on; otherwise, the writer will appear closed.\n     *\n     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n     * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n     * other producers from writing in an interleaved manner.\n     */\n    releaseLock() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('releaseLock');\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return;\n        }\n        WritableStreamDefaultWriterRelease(this);\n    }\n    write(chunk = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        return WritableStreamDefaultWriterWrite(this, chunk);\n    }\n}\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    releaseLock: { enumerable: true },\n    write: { enumerable: true },\n    closed: { enumerable: true },\n    desiredSize: { enumerable: true },\n    ready: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultWriter',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStreamDefaultWriter.\nfunction IsWritableStreamDefaultWriter(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n        return false;\n    }\n    return x instanceof WritableStreamDefaultWriter;\n}\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamAbort(stream, reason);\n}\nfunction WritableStreamDefaultWriterClose(writer) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamClose(stream);\n}\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return WritableStreamDefaultWriterClose(writer);\n}\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n    if (writer._closedPromiseState === 'pending') {\n        defaultWriterClosedPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterClosedPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n    if (writer._readyPromiseState === 'pending') {\n        defaultWriterReadyPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterReadyPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (state === 'errored' || state === 'erroring') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\nfunction WritableStreamDefaultWriterRelease(writer) {\n    const stream = writer._ownerWritableStream;\n    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n    // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n    // rejected until afterwards. This means that simply testing state will not work.\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n    stream._writer = undefined;\n    writer._ownerWritableStream = undefined;\n}\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n    const stream = writer._ownerWritableStream;\n    const controller = stream._writableStreamController;\n    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n    if (stream !== writer._ownerWritableStream) {\n        return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n    const state = stream._state;\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n    }\n    if (state === 'erroring') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    const promise = WritableStreamAddWriteRequest(stream);\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n    return promise;\n}\nconst closeSentinel = {};\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nclass WritableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n     *\n     * @deprecated\n     *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n     *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n     */\n    get abortReason() {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$2('abortReason');\n        }\n        return this._abortReason;\n    }\n    /**\n     * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n     */\n    get signal() {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$2('signal');\n        }\n        if (this._abortController === undefined) {\n            // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n            // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n            // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n            throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n        }\n        return this._abortController.signal;\n    }\n    /**\n     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n     *\n     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n     * normal lifecycle of interactions with the underlying sink.\n     */\n    error(e = undefined) {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$2('error');\n        }\n        const state = this._controlledWritableStream._state;\n        if (state !== 'writable') {\n            // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n            // just treat it as a no-op.\n            return;\n        }\n        WritableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [AbortSteps](reason) {\n        const result = this._abortAlgorithm(reason);\n        WritableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [ErrorSteps]() {\n        ResetQueue(this);\n    }\n}\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n    abortReason: { enumerable: true },\n    signal: { enumerable: true },\n    error: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations implementing interface required by the WritableStream.\nfunction IsWritableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n        return false;\n    }\n    return x instanceof WritableStreamDefaultController;\n}\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledWritableStream = stream;\n    stream._writableStreamController = controller;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._abortReason = undefined;\n    controller._abortController = createAbortController();\n    controller._started = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._writeAlgorithm = writeAlgorithm;\n    controller._closeAlgorithm = closeAlgorithm;\n    controller._abortAlgorithm = abortAlgorithm;\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n    const startResult = startAlgorithm();\n    const startPromise = promiseResolvedWith(startResult);\n    uponPromise(startPromise, () => {\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, r => {\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n    });\n}\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let writeAlgorithm = () => promiseResolvedWith(undefined);\n    let closeAlgorithm = () => promiseResolvedWith(undefined);\n    let abortAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSink.start !== undefined) {\n        startAlgorithm = () => underlyingSink.start(controller);\n    }\n    if (underlyingSink.write !== undefined) {\n        writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n    }\n    if (underlyingSink.close !== undefined) {\n        closeAlgorithm = () => underlyingSink.close();\n    }\n    if (underlyingSink.abort !== undefined) {\n        abortAlgorithm = reason => underlyingSink.abort(reason);\n    }\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._writeAlgorithm = undefined;\n    controller._closeAlgorithm = undefined;\n    controller._abortAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\nfunction WritableStreamDefaultControllerClose(controller) {\n    EnqueueValueWithSize(controller, closeSentinel, 0);\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n    try {\n        return controller._strategySizeAlgorithm(chunk);\n    }\n    catch (chunkSizeE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n        return 1;\n    }\n}\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n    try {\n        EnqueueValueWithSize(controller, chunk, chunkSize);\n    }\n    catch (enqueueE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n        return;\n    }\n    const stream = controller._controlledWritableStream;\n    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n// Abstract operations for the WritableStreamDefaultController.\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n    const stream = controller._controlledWritableStream;\n    if (!controller._started) {\n        return;\n    }\n    if (stream._inFlightWriteRequest !== undefined) {\n        return;\n    }\n    const state = stream._state;\n    if (state === 'erroring') {\n        WritableStreamFinishErroring(stream);\n        return;\n    }\n    if (controller._queue.length === 0) {\n        return;\n    }\n    const value = PeekQueueValue(controller);\n    if (value === closeSentinel) {\n        WritableStreamDefaultControllerProcessClose(controller);\n    }\n    else {\n        WritableStreamDefaultControllerProcessWrite(controller, value);\n    }\n}\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n    if (controller._controlledWritableStream._state === 'writable') {\n        WritableStreamDefaultControllerError(controller, error);\n    }\n}\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkCloseRequestInFlight(stream);\n    DequeueValue(controller);\n    const sinkClosePromise = controller._closeAlgorithm();\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    uponPromise(sinkClosePromise, () => {\n        WritableStreamFinishInFlightClose(stream);\n    }, reason => {\n        WritableStreamFinishInFlightCloseWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\n    const sinkWritePromise = controller._writeAlgorithm(chunk);\n    uponPromise(sinkWritePromise, () => {\n        WritableStreamFinishInFlightWrite(stream);\n        const state = stream._state;\n        DequeueValue(controller);\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, reason => {\n        if (stream._state === 'writable') {\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n        }\n        WritableStreamFinishInFlightWriteWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n    return desiredSize <= 0;\n}\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\nfunction WritableStreamDefaultControllerError(controller, error) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    WritableStreamStartErroring(stream, error);\n}\n// Helper functions for the WritableStream.\nfunction streamBrandCheckException$2(name) {\n    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n// Helper functions for the WritableStreamDefaultController.\nfunction defaultControllerBrandCheckException$2(name) {\n    return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n}\n// Helper functions for the WritableStreamDefaultWriter.\nfunction defaultWriterBrandCheckException(name) {\n    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\nfunction defaultWriterLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\nfunction defaultWriterClosedPromiseInitialize(writer) {\n    writer._closedPromise = newPromise((resolve, reject) => {\n        writer._closedPromise_resolve = resolve;\n        writer._closedPromise_reject = reject;\n        writer._closedPromiseState = 'pending';\n    });\n}\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseReject(writer, reason);\n}\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseResolve(writer);\n}\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n    if (writer._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._closedPromise);\n    writer._closedPromise_reject(reason);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'rejected';\n}\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterClosedPromiseResolve(writer) {\n    if (writer._closedPromise_resolve === undefined) {\n        return;\n    }\n    writer._closedPromise_resolve(undefined);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'resolved';\n}\nfunction defaultWriterReadyPromiseInitialize(writer) {\n    writer._readyPromise = newPromise((resolve, reject) => {\n        writer._readyPromise_resolve = resolve;\n        writer._readyPromise_reject = reject;\n    });\n    writer._readyPromiseState = 'pending';\n}\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseReject(writer, reason);\n}\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseResolve(writer);\n}\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n    if (writer._readyPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._readyPromise);\n    writer._readyPromise_reject(reason);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'rejected';\n}\nfunction defaultWriterReadyPromiseReset(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n}\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterReadyPromiseResolve(writer) {\n    if (writer._readyPromise_resolve === undefined) {\n        return;\n    }\n    writer._readyPromise_resolve(undefined);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'fulfilled';\n}\n\n/// <reference lib=\"dom\" />\nconst NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n/// <reference types=\"node\" />\nfunction isDOMExceptionConstructor(ctor) {\n    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n        return false;\n    }\n    try {\n        new ctor();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction createDOMExceptionPolyfill() {\n    // eslint-disable-next-line no-shadow\n    const ctor = function DOMException(message, name) {\n        this.message = message || '';\n        this.name = name || 'Error';\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    };\n    ctor.prototype = Object.create(Error.prototype);\n    Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n    return ctor;\n}\n// eslint-disable-next-line no-redeclare\nconst DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n    const reader = AcquireReadableStreamDefaultReader(source);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n    source._disturbed = true;\n    let shuttingDown = false;\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = promiseResolvedWith(undefined);\n    return newPromise((resolve, reject) => {\n        let abortAlgorithm;\n        if (signal !== undefined) {\n            abortAlgorithm = () => {\n                const error = new DOMException$1('Aborted', 'AbortError');\n                const actions = [];\n                if (!preventAbort) {\n                    actions.push(() => {\n                        if (dest._state === 'writable') {\n                            return WritableStreamAbort(dest, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                if (!preventCancel) {\n                    actions.push(() => {\n                        if (source._state === 'readable') {\n                            return ReadableStreamCancel(source, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n            };\n            if (signal.aborted) {\n                abortAlgorithm();\n                return;\n            }\n            signal.addEventListener('abort', abortAlgorithm);\n        }\n        // Using reader and writer, read all chunks from this and write them to dest\n        // - Backpressure must be enforced\n        // - Shutdown must stop all activity\n        function pipeLoop() {\n            return newPromise((resolveLoop, rejectLoop) => {\n                function next(done) {\n                    if (done) {\n                        resolveLoop();\n                    }\n                    else {\n                        // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                        // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                        PerformPromiseThen(pipeStep(), next, rejectLoop);\n                    }\n                }\n                next(false);\n            });\n        }\n        function pipeStep() {\n            if (shuttingDown) {\n                return promiseResolvedWith(true);\n            }\n            return PerformPromiseThen(writer._readyPromise, () => {\n                return newPromise((resolveRead, rejectRead) => {\n                    ReadableStreamDefaultReaderRead(reader, {\n                        _chunkSteps: chunk => {\n                            currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                            resolveRead(false);\n                        },\n                        _closeSteps: () => resolveRead(true),\n                        _errorSteps: rejectRead\n                    });\n                });\n            });\n        }\n        // Errors must be propagated forward\n        isOrBecomesErrored(source, reader._closedPromise, storedError => {\n            if (!preventAbort) {\n                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Errors must be propagated backward\n        isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Closing must be propagated forward\n        isOrBecomesClosed(source, reader._closedPromise, () => {\n            if (!preventClose) {\n                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n            }\n            else {\n                shutdown();\n            }\n        });\n        // Closing must be propagated backward\n        if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n            const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n            }\n            else {\n                shutdown(true, destClosed);\n            }\n        }\n        setPromiseIsHandledToTrue(pipeLoop());\n        function waitForWritesToFinish() {\n            // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n            // for that too.\n            const oldCurrentWrite = currentWrite;\n            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n        }\n        function isOrBecomesErrored(stream, promise, action) {\n            if (stream._state === 'errored') {\n                action(stream._storedError);\n            }\n            else {\n                uponRejection(promise, action);\n            }\n        }\n        function isOrBecomesClosed(stream, promise, action) {\n            if (stream._state === 'closed') {\n                action();\n            }\n            else {\n                uponFulfillment(promise, action);\n            }\n        }\n        function shutdownWithAction(action, originalIsError, originalError) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), doTheRest);\n            }\n            else {\n                doTheRest();\n            }\n            function doTheRest() {\n                uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n            }\n        }\n        function shutdown(isError, error) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n            }\n            else {\n                finalize(isError, error);\n            }\n        }\n        function finalize(isError, error) {\n            WritableStreamDefaultWriterRelease(writer);\n            ReadableStreamReaderGenericRelease(reader);\n            if (signal !== undefined) {\n                signal.removeEventListener('abort', abortAlgorithm);\n            }\n            if (isError) {\n                reject(error);\n            }\n            else {\n                resolve(undefined);\n            }\n        }\n    });\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('desiredSize');\n        }\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('close');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits close');\n        }\n        ReadableStreamDefaultControllerClose(this);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('enqueue');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits enqueue');\n        }\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('error');\n        }\n        ReadableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableStream;\n        if (this._queue.length > 0) {\n            const chunk = DequeueValue(this);\n            if (this._closeRequested && this._queue.length === 0) {\n                ReadableStreamDefaultControllerClearAlgorithms(this);\n                ReadableStreamClose(stream);\n            }\n            else {\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n            readRequest._chunkSteps(chunk);\n        }\n        else {\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n        }\n    }\n}\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStreamDefaultController.\nfunction IsReadableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n        return false;\n    }\n    return x instanceof ReadableStreamDefaultController;\n}\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableStreamDefaultControllerError(controller, e);\n    });\n}\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableStream;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\nfunction ReadableStreamDefaultControllerClose(controller) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    controller._closeRequested = true;\n    if (controller._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n}\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        ReadableStreamFulfillReadRequest(stream, chunk, false);\n    }\n    else {\n        let chunkSize;\n        try {\n            chunkSize = controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            ReadableStreamDefaultControllerError(controller, chunkSizeE);\n            throw chunkSizeE;\n        }\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            ReadableStreamDefaultControllerError(controller, enqueueE);\n            throw enqueueE;\n        }\n    }\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction ReadableStreamDefaultControllerError(controller, e) {\n    const stream = controller._controlledReadableStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ResetQueue(controller);\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (!controller._closeRequested && state === 'readable') {\n        return true;\n    }\n    return false;\n}\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledReadableStream = stream;\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._closeRequested = false;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableStreamDefaultControllerError(controller, r);\n    });\n}\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSource.start !== undefined) {\n        startAlgorithm = () => underlyingSource.start(controller);\n    }\n    if (underlyingSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingSource.pull(controller);\n    }\n    if (underlyingSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingSource.cancel(reason);\n    }\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// Helper functions for the ReadableStreamDefaultController.\nfunction defaultControllerBrandCheckException$1(name) {\n    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n    if (IsReadableByteStreamController(stream._readableStreamController)) {\n        return ReadableByteStreamTee(stream);\n    }\n    return ReadableStreamDefaultTee(stream);\n}\nfunction ReadableStreamDefaultTee(stream, cloneForBranch2) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let readAgain = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function pullAlgorithm() {\n        if (reading) {\n            readAgain = true;\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const readRequest = {\n            _chunkSteps: chunk => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    readAgain = false;\n                    const chunk1 = chunk;\n                    const chunk2 = chunk;\n                    // There is no way to access the cloning code right now in the reference implementation.\n                    // If we add one then we'll need an implementation for serializable objects.\n                    // if (!canceled2 && cloneForBranch2) {\n                    //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                    // }\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                    }\n                    reading = false;\n                    if (readAgain) {\n                        pullAlgorithm();\n                    }\n                });\n            },\n            _closeSteps: () => {\n                reading = false;\n                if (!canceled1) {\n                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                }\n                if (!canceled2) {\n                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                }\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() {\n        // do nothing\n    }\n    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n    uponRejection(reader._closedPromise, (r) => {\n        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n        if (!canceled1 || !canceled2) {\n            resolveCancelPromise(undefined);\n        }\n    });\n    return [branch1, branch2];\n}\nfunction ReadableByteStreamTee(stream) {\n    let reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let readAgainForBranch1 = false;\n    let readAgainForBranch2 = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function forwardReaderError(thisReader) {\n        uponRejection(thisReader._closedPromise, r => {\n            if (thisReader !== reader) {\n                return;\n            }\n            ReadableByteStreamControllerError(branch1._readableStreamController, r);\n            ReadableByteStreamControllerError(branch2._readableStreamController, r);\n            if (!canceled1 || !canceled2) {\n                resolveCancelPromise(undefined);\n            }\n        });\n    }\n    function pullWithDefaultReader() {\n        if (IsReadableStreamBYOBReader(reader)) {\n            ReadableStreamReaderGenericRelease(reader);\n            reader = AcquireReadableStreamDefaultReader(stream);\n            forwardReaderError(reader);\n        }\n        const readRequest = {\n            _chunkSteps: chunk => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    readAgainForBranch1 = false;\n                    readAgainForBranch2 = false;\n                    const chunk1 = chunk;\n                    let chunk2 = chunk;\n                    if (!canceled1 && !canceled2) {\n                        try {\n                            chunk2 = CloneAsUint8Array(chunk);\n                        }\n                        catch (cloneE) {\n                            ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                            ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                            resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                            return;\n                        }\n                    }\n                    if (!canceled1) {\n                        ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                    }\n                    if (!canceled2) {\n                        ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                    }\n                    reading = false;\n                    if (readAgainForBranch1) {\n                        pull1Algorithm();\n                    }\n                    else if (readAgainForBranch2) {\n                        pull2Algorithm();\n                    }\n                });\n            },\n            _closeSteps: () => {\n                reading = false;\n                if (!canceled1) {\n                    ReadableByteStreamControllerClose(branch1._readableStreamController);\n                }\n                if (!canceled2) {\n                    ReadableByteStreamControllerClose(branch2._readableStreamController);\n                }\n                if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                }\n                if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                }\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n    }\n    function pullWithBYOBReader(view, forBranch2) {\n        if (IsReadableStreamDefaultReader(reader)) {\n            ReadableStreamReaderGenericRelease(reader);\n            reader = AcquireReadableStreamBYOBReader(stream);\n            forwardReaderError(reader);\n        }\n        const byobBranch = forBranch2 ? branch2 : branch1;\n        const otherBranch = forBranch2 ? branch1 : branch2;\n        const readIntoRequest = {\n            _chunkSteps: chunk => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    readAgainForBranch1 = false;\n                    readAgainForBranch2 = false;\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                    if (!otherCanceled) {\n                        let clonedChunk;\n                        try {\n                            clonedChunk = CloneAsUint8Array(chunk);\n                        }\n                        catch (cloneE) {\n                            ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                            ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                            resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                            return;\n                        }\n                        if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                    }\n                    else if (!byobCanceled) {\n                        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                    }\n                    reading = false;\n                    if (readAgainForBranch1) {\n                        pull1Algorithm();\n                    }\n                    else if (readAgainForBranch2) {\n                        pull2Algorithm();\n                    }\n                });\n            },\n            _closeSteps: chunk => {\n                reading = false;\n                const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                if (!byobCanceled) {\n                    ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                }\n                if (!otherCanceled) {\n                    ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                }\n                if (chunk !== undefined) {\n                    if (!byobCanceled) {\n                        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                    }\n                    if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                    }\n                }\n                if (!byobCanceled || !otherCanceled) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n    }\n    function pull1Algorithm() {\n        if (reading) {\n            readAgainForBranch1 = true;\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n        if (byobRequest === null) {\n            pullWithDefaultReader();\n        }\n        else {\n            pullWithBYOBReader(byobRequest._view, false);\n        }\n        return promiseResolvedWith(undefined);\n    }\n    function pull2Algorithm() {\n        if (reading) {\n            readAgainForBranch2 = true;\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n        if (byobRequest === null) {\n            pullWithDefaultReader();\n        }\n        else {\n            pullWithBYOBReader(byobRequest._view, true);\n        }\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() {\n        return;\n    }\n    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n    forwardReaderError(reader);\n    return [branch1, branch2];\n}\n\nfunction convertUnderlyingDefaultOrByteSource(source, context) {\n    assertDictionary(source, context);\n    const original = source;\n    const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n    const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n    const pull = original === null || original === void 0 ? void 0 : original.pull;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    return {\n        autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n            undefined :\n            convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n        cancel: cancel === undefined ?\n            undefined :\n            convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n        pull: pull === undefined ?\n            undefined :\n            convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n        type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n    };\n}\nfunction convertUnderlyingSourceCancelCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSourcePullCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSourceStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertReadableStreamType(type, context) {\n    type = `${type}`;\n    if (type !== 'bytes') {\n        throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n    }\n    return type;\n}\n\nfunction convertReaderOptions(options, context) {\n    assertDictionary(options, context);\n    const mode = options === null || options === void 0 ? void 0 : options.mode;\n    return {\n        mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n    };\n}\nfunction convertReadableStreamReaderMode(mode, context) {\n    mode = `${mode}`;\n    if (mode !== 'byob') {\n        throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n    }\n    return mode;\n}\n\nfunction convertIteratorOptions(options, context) {\n    assertDictionary(options, context);\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    return { preventCancel: Boolean(preventCancel) };\n}\n\nfunction convertPipeOptions(options, context) {\n    assertDictionary(options, context);\n    const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal !== undefined) {\n        assertAbortSignal(signal, `${context} has member 'signal' that`);\n    }\n    return {\n        preventAbort: Boolean(preventAbort),\n        preventCancel: Boolean(preventCancel),\n        preventClose: Boolean(preventClose),\n        signal\n    };\n}\nfunction assertAbortSignal(signal, context) {\n    if (!isAbortSignal(signal)) {\n        throw new TypeError(`${context} is not an AbortSignal.`);\n    }\n}\n\nfunction convertReadableWritablePair(pair, context) {\n    assertDictionary(pair, context);\n    const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n    assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n    assertReadableStream(readable, `${context} has member 'readable' that`);\n    const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n    assertWritableStream(writable, `${context} has member 'writable' that`);\n    return { readable, writable };\n}\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nclass ReadableStream {\n    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n        if (rawUnderlyingSource === undefined) {\n            rawUnderlyingSource = null;\n        }\n        else {\n            assertObject(rawUnderlyingSource, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n        InitializeReadableStream(this);\n        if (underlyingSource.type === 'bytes') {\n            if (strategy.size !== undefined) {\n                throw new RangeError('The strategy for a byte stream cannot have a size function');\n            }\n            const highWaterMark = ExtractHighWaterMark(strategy, 0);\n            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n        }\n        else {\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n        }\n    }\n    /**\n     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n     */\n    get locked() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('locked');\n        }\n        return IsReadableStreamLocked(this);\n    }\n    /**\n     * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n     *\n     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n     * method, which might or might not use it.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n        }\n        return ReadableStreamCancel(this, reason);\n    }\n    getReader(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('getReader');\n        }\n        const options = convertReaderOptions(rawOptions, 'First parameter');\n        if (options.mode === undefined) {\n            return AcquireReadableStreamDefaultReader(this);\n        }\n        return AcquireReadableStreamBYOBReader(this);\n    }\n    pipeThrough(rawTransform, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('pipeThrough');\n        }\n        assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n        const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n        const options = convertPipeOptions(rawOptions, 'Second parameter');\n        if (IsReadableStreamLocked(this)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n        }\n        if (IsWritableStreamLocked(transform.writable)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n        }\n        const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        setPromiseIsHandledToTrue(promise);\n        return transform.readable;\n    }\n    pipeTo(destination, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n        }\n        if (destination === undefined) {\n            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n        }\n        if (!IsWritableStream(destination)) {\n            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n        }\n        let options;\n        try {\n            options = convertPipeOptions(rawOptions, 'Second parameter');\n        }\n        catch (e) {\n            return promiseRejectedWith(e);\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n        }\n        if (IsWritableStreamLocked(destination)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n        }\n        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n    }\n    /**\n     * Tees this readable stream, returning a two-element array containing the two resulting branches as\n     * new {@link ReadableStream} instances.\n     *\n     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n     * propagated to the stream's underlying source.\n     *\n     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n     * this could allow interference between the two branches.\n     */\n    tee() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('tee');\n        }\n        const branches = ReadableStreamTee(this);\n        return CreateArrayFromList(branches);\n    }\n    values(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('values');\n        }\n        const options = convertIteratorOptions(rawOptions, 'First parameter');\n        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n    }\n}\nObject.defineProperties(ReadableStream.prototype, {\n    cancel: { enumerable: true },\n    getReader: { enumerable: true },\n    pipeThrough: { enumerable: true },\n    pipeTo: { enumerable: true },\n    tee: { enumerable: true },\n    values: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStream',\n        configurable: true\n    });\n}\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n        value: ReadableStream.prototype.values,\n        writable: true,\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStream.\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n    return stream;\n}\nfunction InitializeReadableStream(stream) {\n    stream._state = 'readable';\n    stream._reader = undefined;\n    stream._storedError = undefined;\n    stream._disturbed = false;\n}\nfunction IsReadableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n        return false;\n    }\n    return x instanceof ReadableStream;\n}\nfunction IsReadableStreamLocked(stream) {\n    if (stream._reader === undefined) {\n        return false;\n    }\n    return true;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamCancel(stream, reason) {\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    ReadableStreamClose(stream);\n    const reader = stream._reader;\n    if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._closeSteps(undefined);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n    return transformPromiseWith(sourceCancelPromise, noop);\n}\nfunction ReadableStreamClose(stream) {\n    stream._state = 'closed';\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseResolve(reader);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._closeSteps();\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n}\nfunction ReadableStreamError(stream, e) {\n    stream._state = 'errored';\n    stream._storedError = e;\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseReject(reader, e);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._errorSteps(e);\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    else {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._errorSteps(e);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n}\n// Helper functions for the ReadableStream.\nfunction streamBrandCheckException$1(name) {\n    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\nfunction convertQueuingStrategyInit(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n    return {\n        highWaterMark: convertUnrestrictedDouble(highWaterMark)\n    };\n}\n\n// The size function must not have a prototype property nor be a constructor\nconst byteLengthSizeFunction = (chunk) => {\n    return chunk.byteLength;\n};\nObject.defineProperty(byteLengthSizeFunction, 'name', {\n    value: 'size',\n    configurable: true\n});\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nclass ByteLengthQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('highWaterMark');\n        }\n        return this._byteLengthQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by returning the value of its `byteLength` property.\n     */\n    get size() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('size');\n        }\n        return byteLengthSizeFunction;\n    }\n}\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ByteLengthQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the ByteLengthQueuingStrategy.\nfunction byteLengthBrandCheckException(name) {\n    return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\nfunction IsByteLengthQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return x instanceof ByteLengthQueuingStrategy;\n}\n\n// The size function must not have a prototype property nor be a constructor\nconst countSizeFunction = () => {\n    return 1;\n};\nObject.defineProperty(countSizeFunction, 'name', {\n    value: 'size',\n    configurable: true\n});\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nclass CountQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('highWaterMark');\n        }\n        return this._countQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by always returning 1.\n     * This ensures that the total queue size is a count of the number of chunks in the queue.\n     */\n    get size() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('size');\n        }\n        return countSizeFunction;\n    }\n}\nObject.defineProperties(CountQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'CountQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the CountQueuingStrategy.\nfunction countBrandCheckException(name) {\n    return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\nfunction IsCountQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return x instanceof CountQueuingStrategy;\n}\n\nfunction convertTransformer(original, context) {\n    assertDictionary(original, context);\n    const flush = original === null || original === void 0 ? void 0 : original.flush;\n    const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const transform = original === null || original === void 0 ? void 0 : original.transform;\n    const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n    return {\n        flush: flush === undefined ?\n            undefined :\n            convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n        readableType,\n        start: start === undefined ?\n            undefined :\n            convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n        transform: transform === undefined ?\n            undefined :\n            convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n        writableType\n    };\n}\nfunction convertTransformerFlushCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertTransformerStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertTransformerTransformCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\n// Class TransformStream\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nclass TransformStream {\n    constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n        if (rawTransformer === undefined) {\n            rawTransformer = null;\n        }\n        const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n        const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n        const transformer = convertTransformer(rawTransformer, 'First parameter');\n        if (transformer.readableType !== undefined) {\n            throw new RangeError('Invalid readableType specified');\n        }\n        if (transformer.writableType !== undefined) {\n            throw new RangeError('Invalid writableType specified');\n        }\n        const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n        const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n        const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n        const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n        let startPromise_resolve;\n        const startPromise = newPromise(resolve => {\n            startPromise_resolve = resolve;\n        });\n        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n        if (transformer.start !== undefined) {\n            startPromise_resolve(transformer.start(this._transformStreamController));\n        }\n        else {\n            startPromise_resolve(undefined);\n        }\n    }\n    /**\n     * The readable side of the transform stream.\n     */\n    get readable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('readable');\n        }\n        return this._readable;\n    }\n    /**\n     * The writable side of the transform stream.\n     */\n    get writable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('writable');\n        }\n        return this._writable;\n    }\n}\nObject.defineProperties(TransformStream.prototype, {\n    readable: { enumerable: true },\n    writable: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStream',\n        configurable: true\n    });\n}\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n    function startAlgorithm() {\n        return startPromise;\n    }\n    function writeAlgorithm(chunk) {\n        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    }\n    function abortAlgorithm(reason) {\n        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    }\n    function closeAlgorithm() {\n        return TransformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n    function pullAlgorithm() {\n        return TransformStreamDefaultSourcePullAlgorithm(stream);\n    }\n    function cancelAlgorithm(reason) {\n        TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n    stream._backpressure = undefined;\n    stream._backpressureChangePromise = undefined;\n    stream._backpressureChangePromise_resolve = undefined;\n    TransformStreamSetBackpressure(stream, true);\n    stream._transformStreamController = undefined;\n}\nfunction IsTransformStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n        return false;\n    }\n    return x instanceof TransformStream;\n}\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n    if (stream._backpressure) {\n        // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n        // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n        // _backpressure is set.\n        TransformStreamSetBackpressure(stream, false);\n    }\n}\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n    // Passes also when called during construction.\n    if (stream._backpressureChangePromise !== undefined) {\n        stream._backpressureChangePromise_resolve();\n    }\n    stream._backpressureChangePromise = newPromise(resolve => {\n        stream._backpressureChangePromise_resolve = resolve;\n    });\n    stream._backpressure = backpressure;\n}\n// Class TransformStreamDefaultController\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nclass TransformStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n     */\n    get desiredSize() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('desiredSize');\n        }\n        const readableController = this._controlledTransformStream._readable._readableStreamController;\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('enqueue');\n        }\n        TransformStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors both the readable side and the writable side of the controlled transform stream, making all future\n     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n     */\n    error(reason = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('error');\n        }\n        TransformStreamDefaultControllerError(this, reason);\n    }\n    /**\n     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n     * transformer only needs to consume a portion of the chunks written to the writable side.\n     */\n    terminate() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('terminate');\n        }\n        TransformStreamDefaultControllerTerminate(this);\n    }\n}\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    terminate: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStreamDefaultController',\n        configurable: true\n    });\n}\n// Transform Stream Default Controller Abstract Operations\nfunction IsTransformStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n        return false;\n    }\n    return x instanceof TransformStreamDefaultController;\n}\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n    controller._controlledTransformStream = stream;\n    stream._transformStreamController = controller;\n    controller._transformAlgorithm = transformAlgorithm;\n    controller._flushAlgorithm = flushAlgorithm;\n}\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n    const controller = Object.create(TransformStreamDefaultController.prototype);\n    let transformAlgorithm = (chunk) => {\n        try {\n            TransformStreamDefaultControllerEnqueue(controller, chunk);\n            return promiseResolvedWith(undefined);\n        }\n        catch (transformResultE) {\n            return promiseRejectedWith(transformResultE);\n        }\n    };\n    let flushAlgorithm = () => promiseResolvedWith(undefined);\n    if (transformer.transform !== undefined) {\n        transformAlgorithm = chunk => transformer.transform(chunk, controller);\n    }\n    if (transformer.flush !== undefined) {\n        flushAlgorithm = () => transformer.flush(controller);\n    }\n    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n    controller._transformAlgorithm = undefined;\n    controller._flushAlgorithm = undefined;\n}\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n        throw new TypeError('Readable side is not in a state that permits enqueue');\n    }\n    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n    // accept TransformStreamDefaultControllerEnqueue() calls.\n    try {\n        ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n    }\n    catch (e) {\n        // This happens when readableStrategy.size() throws.\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n        throw stream._readable._storedError;\n    }\n    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n    if (backpressure !== stream._backpressure) {\n        TransformStreamSetBackpressure(stream, true);\n    }\n}\nfunction TransformStreamDefaultControllerError(controller, e) {\n    TransformStreamError(controller._controlledTransformStream, e);\n}\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n    const transformPromise = controller._transformAlgorithm(chunk);\n    return transformPromiseWith(transformPromise, undefined, r => {\n        TransformStreamError(controller._controlledTransformStream, r);\n        throw r;\n    });\n}\nfunction TransformStreamDefaultControllerTerminate(controller) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    ReadableStreamDefaultControllerClose(readableController);\n    const error = new TypeError('TransformStream terminated');\n    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n// TransformStreamDefaultSink Algorithms\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n    const controller = stream._transformStreamController;\n    if (stream._backpressure) {\n        const backpressureChangePromise = stream._backpressureChangePromise;\n        return transformPromiseWith(backpressureChangePromise, () => {\n            const writable = stream._writable;\n            const state = writable._state;\n            if (state === 'erroring') {\n                throw writable._storedError;\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n    // errored.\n    TransformStreamError(stream, reason);\n    return promiseResolvedWith(undefined);\n}\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n    const readable = stream._readable;\n    const controller = stream._transformStreamController;\n    const flushPromise = controller._flushAlgorithm();\n    TransformStreamDefaultControllerClearAlgorithms(controller);\n    // Return a promise that is fulfilled with undefined on success.\n    return transformPromiseWith(flushPromise, () => {\n        if (readable._state === 'errored') {\n            throw readable._storedError;\n        }\n        ReadableStreamDefaultControllerClose(readable._readableStreamController);\n    }, r => {\n        TransformStreamError(stream, r);\n        throw readable._storedError;\n    });\n}\n// TransformStreamDefaultSource Algorithms\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n    // Invariant. Enforced by the promises returned by start() and pull().\n    TransformStreamSetBackpressure(stream, false);\n    // Prevent the next pull() call until there is backpressure.\n    return stream._backpressureChangePromise;\n}\n// Helper functions for the TransformStreamDefaultController.\nfunction defaultControllerBrandCheckException(name) {\n    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n// Helper functions for the TransformStream.\nfunction streamBrandCheckException(name) {\n    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n\nexport { ByteLengthQueuingStrategy, CountQueuingStrategy, ReadableByteStreamController, ReadableStream, ReadableStreamBYOBReader, ReadableStreamBYOBRequest, ReadableStreamDefaultController, ReadableStreamDefaultReader, TransformStream, TransformStreamDefaultController, WritableStream, WritableStreamDefaultController, WritableStreamDefaultWriter };\n//# sourceMappingURL=ponyfill.es2018.mjs.map\n"],"names":["SymbolPolyfill","Symbol","iterator","description","noop","globals","self","window","global","typeIsObject","x","rethrowAssertionErrorRejection","originalPromise","Promise","originalPromiseThen","prototype","then","originalPromiseResolve","resolve","bind","originalPromiseReject","reject","newPromise","executor","promiseResolvedWith","value","promiseRejectedWith","reason","PerformPromiseThen","promise","onFulfilled","onRejected","call","uponPromise","undefined","uponFulfillment","uponRejection","transformPromiseWith","fulfillmentHandler","rejectionHandler","setPromiseIsHandledToTrue","queueMicrotask","globalQueueMicrotask","resolvedPromise","fn","reflectCall","F","V","args","TypeError","Function","apply","promiseCall","SimpleQueue","constructor","this","_cursor","_size","_front","_elements","_next","_back","length","push","element","oldBack","newBack","QUEUE_MAX_ARRAY_SIZE","shift","oldFront","newFront","oldCursor","newCursor","elements","forEach","callback","i","node","peek","front","cursor","ReadableStreamReaderGenericInitialize","reader","stream","_ownerReadableStream","_reader","_state","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseResolve","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","_storedError","ReadableStreamReaderGenericCancel","ReadableStreamCancel","ReadableStreamReaderGenericRelease","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","readerLockException","name","_closedPromise","_closedPromise_resolve","_closedPromise_reject","AbortSteps","ErrorSteps","CancelSteps","PullSteps","NumberIsFinite","Number","isFinite","MathTrunc","Math","trunc","v","ceil","floor","assertDictionary","obj","context","assertFunction","assertObject","isObject","assertRequiredArgument","position","assertRequiredField","field","convertUnrestrictedDouble","censorNegativeZero","convertUnsignedLongLongWithEnforceRange","upperBound","MAX_SAFE_INTEGER","integerPart","assertReadableStream","IsReadableStream","AcquireReadableStreamDefaultReader","ReadableStreamDefaultReader","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamFulfillReadRequest","chunk","done","_closeSteps","_chunkSteps","ReadableStreamGetNumReadRequests","ReadableStreamHasDefaultReader","IsReadableStreamDefaultReader","IsReadableStreamLocked","closed","defaultReaderBrandCheckException","cancel","read","resolvePromise","rejectPromise","ReadableStreamDefaultReaderRead","_errorSteps","e","releaseLock","Object","hasOwnProperty","_disturbed","_readableStreamController","defineProperties","enumerable","toStringTag","defineProperty","configurable","AsyncIteratorPrototype","getPrototypeOf","async","ReadableStreamAsyncIteratorImpl","preventCancel","_ongoingPromise","_isFinished","_preventCancel","next","nextSteps","_nextSteps","return","returnSteps","_returnSteps","result","ReadableStreamAsyncIteratorPrototype","IsReadableStreamAsyncIterator","_asyncIteratorImpl","streamAsyncIteratorBrandCheckException","_a","setPrototypeOf","NumberIsNaN","isNaN","CreateArrayFromList","slice","CopyDataBlockBytes","dest","destOffset","src","srcOffset","n","Uint8Array","set","ArrayBufferSlice","buffer","begin","end","ArrayBuffer","CloneAsUint8Array","O","byteOffset","byteLength","DequeueValue","container","pair","_queue","_queueTotalSize","size","EnqueueValueWithSize","Infinity","RangeError","ResetQueue","ReadableStreamBYOBRequest","view","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","respond","bytesWritten","_associatedReadableByteStreamController","ReadableByteStreamControllerRespond","respondWithNewView","isView","ReadableByteStreamControllerRespondWithNewView","ReadableByteStreamController","byobRequest","IsReadableByteStreamController","byteStreamControllerBrandCheckException","ReadableByteStreamControllerGetBYOBRequest","desiredSize","ReadableByteStreamControllerGetDesiredSize","close","_closeRequested","state","_controlledReadableByteStream","ReadableByteStreamControllerClose","enqueue","ReadableByteStreamControllerEnqueue","error","ReadableByteStreamControllerError","ReadableByteStreamControllerClearPendingPullIntos","_cancelAlgorithm","ReadableByteStreamControllerClearAlgorithms","entry","ReadableByteStreamControllerHandleQueueDrain","autoAllocateChunkSize","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","bufferByteLength","bytesFilled","elementSize","viewConstructor","readerType","_pendingPullIntos","ReadableByteStreamControllerCallPullIfNeeded","controller","shouldPull","_started","ReadableStreamHasBYOBReader","ReadableStreamGetNumReadIntoRequests","ReadableByteStreamControllerShouldCallPull","_pulling","_pullAgain","_pullAlgorithm","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","readIntoRequest","_readIntoRequests","ReadableStreamFulfillReadIntoRequest","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableStreamClose","_byobRequest","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInternal","firstDescriptor","ReadableByteStreamControllerRespondInClosedState","remainderSize","remainder","ReadableByteStreamControllerRespondInReadableState","transferredBuffer","firstPendingPullInto","ReadableStreamError","create","request","SetUpReadableStreamBYOBRequest","_strategyHWM","viewByteLength","SetUpReadableByteStreamController","startAlgorithm","pullAlgorithm","cancelAlgorithm","highWaterMark","r","AcquireReadableStreamBYOBReader","ReadableStreamBYOBReader","ReadableStreamAddReadIntoRequest","IsReadableStreamBYOBReader","byobReaderBrandCheckException","ReadableStreamBYOBReaderRead","DataView","BYTES_PER_ELEMENT","ctor","emptyView","ReadableByteStreamControllerPullInto","ExtractHighWaterMark","strategy","defaultHWM","ExtractSizeAlgorithm","convertQueuingStrategy","init","convertQueuingStrategySize","convertUnderlyingSinkAbortCallback","original","convertUnderlyingSinkCloseCallback","convertUnderlyingSinkStartCallback","convertUnderlyingSinkWriteCallback","assertWritableStream","IsWritableStream","supportsAbortController","AbortController","WritableStream","rawUnderlyingSink","rawStrategy","underlyingSink","abort","start","type","write","convertUnderlyingSink","InitializeWritableStream","sizeAlgorithm","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","streamBrandCheckException$2","IsWritableStreamLocked","WritableStreamAbort","WritableStreamCloseQueuedOrInFlight","WritableStreamClose","getWriter","AcquireWritableStreamDefaultWriter","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","_abortReason","_abortController","_promise","wasAlreadyErroring","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","closeRequest","writer","defaultWriterReadyPromiseResolve","closeSentinel","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDealWithRejection","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","storedError","writeRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseReset","_ownerWritableStream","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","_readyPromise","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","WritableStreamDefaultWriterEnsureClosedPromiseRejected","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerGetChunkSize","WritableStreamAddWriteRequest","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","abortReason","IsWritableStreamDefaultController","defaultControllerBrandCheckException$2","signal","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","createAbortController","_writeAlgorithm","_closeAlgorithm","WritableStreamMarkCloseRequestInFlight","sinkClosePromise","WritableStreamFinishInFlightClose","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","_readyPromise_resolve","_readyPromise_reject","NativeDOMException","DOMException","DOMException$1","isDOMExceptionConstructor","message","Error","captureStackTrace","writable","createDOMExceptionPolyfill","ReadableStreamPipeTo","source","preventClose","preventAbort","shuttingDown","currentWrite","actions","shutdownWithAction","all","map","action","aborted","addEventListener","isOrBecomesErrored","shutdown","WritableStreamDefaultWriterCloseWithErrorPropagation","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","removeEventListener","resolveLoop","rejectLoop","resolveRead","rejectRead","ReadableStreamDefaultController","IsReadableStreamDefaultController","defaultControllerBrandCheckException$1","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","ReadableStreamDefaultControllerCallPullIfNeeded","ReadableStreamDefaultControllerShouldCallPull","SetUpReadableStreamDefaultController","convertUnderlyingSourceCancelCallback","convertUnderlyingSourcePullCallback","convertUnderlyingSourceStartCallback","convertReadableStreamType","convertReadableStreamReaderMode","mode","convertPipeOptions","options","isAbortSignal","assertAbortSignal","Boolean","ReadableStream","rawUnderlyingSource","underlyingSource","pull","convertUnderlyingDefaultOrByteSource","InitializeReadableStream","underlyingByteSource","SetUpReadableByteStreamControllerFromUnderlyingSource","SetUpReadableStreamDefaultControllerFromUnderlyingSource","streamBrandCheckException$1","getReader","rawOptions","convertReaderOptions","pipeThrough","rawTransform","transform","readable","convertReadableWritablePair","pipeTo","destination","tee","reason1","reason2","branch1","branch2","resolveCancelPromise","reading","readAgainForBranch1","readAgainForBranch2","canceled1","canceled2","cancelPromise","forwardReaderError","thisReader","pullWithDefaultReader","chunk1","chunk2","cloneE","pull1Algorithm","pull2Algorithm","pullWithBYOBReader","forBranch2","byobBranch","otherBranch","byobCanceled","clonedChunk","otherCanceled","CreateReadableByteStream","compositeReason","cancelResult","ReadableByteStreamTee","cloneForBranch2","readAgain","CreateReadableStream","ReadableStreamDefaultTee","values","impl","AcquireReadableStreamAsyncIterator","convertIteratorOptions","convertQueuingStrategyInit","asyncIterator","byteLengthSizeFunction","ByteLengthQueuingStrategy","_byteLengthQueuingStrategyHighWaterMark","IsByteLengthQueuingStrategy","byteLengthBrandCheckException","countSizeFunction","CountQueuingStrategy","_countQueuingStrategyHighWaterMark","IsCountQueuingStrategy","countBrandCheckException","convertTransformerFlushCallback","convertTransformerStartCallback","convertTransformerTransformCallback","TransformStream","rawTransformer","rawWritableStrategy","rawReadableStrategy","writableStrategy","readableStrategy","transformer","flush","readableType","writableType","convertTransformer","readableHighWaterMark","readableSizeAlgorithm","writableHighWaterMark","writableSizeAlgorithm","startPromise_resolve","startPromise","_writable","CreateWritableStream","_transformStreamController","_backpressureChangePromise","TransformStreamDefaultControllerPerformTransform","TransformStreamDefaultSinkWriteAlgorithm","_readable","flushPromise","_flushAlgorithm","TransformStreamDefaultControllerClearAlgorithms","TransformStreamError","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamSetBackpressure","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise_resolve","InitializeTransformStream","TransformStreamDefaultController","transformAlgorithm","TransformStreamDefaultControllerEnqueue","transformResultE","flushAlgorithm","_controlledTransformStream","_transformAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","IsTransformStream","streamBrandCheckException","IsTransformStreamDefaultController","defaultControllerBrandCheckException","terminate","TransformStreamDefaultControllerTerminate","readableController","ReadableStreamDefaultControllerHasBackpressure"],"sourceRoot":""}