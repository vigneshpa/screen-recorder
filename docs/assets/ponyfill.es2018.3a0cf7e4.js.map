{"version":3,"file":"ponyfill.es2018.3a0cf7e4.js","sources":["../../node_modules/web-streams-polyfill/dist/ponyfill.es2018.mjs"],"sourcesContent":["/**\n * web-streams-polyfill v3.2.0\n */\n/// <reference lib=\"es2015.symbol\" />\nconst SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})`;\n\n/// <reference lib=\"dom\" />\nfunction noop() {\n    return undefined;\n}\nfunction getGlobals() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    else if (typeof window !== 'undefined') {\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        return global;\n    }\n    return undefined;\n}\nconst globals = getGlobals();\n\nfunction typeIsObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nconst rethrowAssertionErrorRejection = noop;\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\nfunction newPromise(executor) {\n    return new originalPromise(executor);\n}\nfunction promiseResolvedWith(value) {\n    return originalPromiseResolve(value);\n}\nfunction promiseRejectedWith(reason) {\n    return originalPromiseReject(reason);\n}\nfunction PerformPromiseThen(promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return originalPromiseThen.call(promise, onFulfilled, onRejected);\n}\nfunction uponPromise(promise, onFulfilled, onRejected) {\n    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n}\nfunction uponFulfillment(promise, onFulfilled) {\n    uponPromise(promise, onFulfilled);\n}\nfunction uponRejection(promise, onRejected) {\n    uponPromise(promise, undefined, onRejected);\n}\nfunction transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\nfunction setPromiseIsHandledToTrue(promise) {\n    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\nconst queueMicrotask = (() => {\n    const globalQueueMicrotask = globals && globals.queueMicrotask;\n    if (typeof globalQueueMicrotask === 'function') {\n        return globalQueueMicrotask;\n    }\n    const resolvedPromise = promiseResolvedWith(undefined);\n    return (fn) => PerformPromiseThen(resolvedPromise, fn);\n})();\nfunction reflectCall(F, V, args) {\n    if (typeof F !== 'function') {\n        throw new TypeError('Argument is not a function');\n    }\n    return Function.prototype.apply.call(F, V, args);\n}\nfunction promiseCall(F, V, args) {\n    try {\n        return promiseResolvedWith(reflectCall(F, V, args));\n    }\n    catch (value) {\n        return promiseRejectedWith(value);\n    }\n}\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nclass SimpleQueue {\n    constructor() {\n        this._cursor = 0;\n        this._size = 0;\n        // _front and _back are always defined.\n        this._front = {\n            _elements: [],\n            _next: undefined\n        };\n        this._back = this._front;\n        // The cursor is used to avoid calling Array.shift().\n        // It contains the index of the front element of the array inside the\n        // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n        this._cursor = 0;\n        // When there is only one node, size === elements.length - cursor.\n        this._size = 0;\n    }\n    get length() {\n        return this._size;\n    }\n    // For exception safety, this method is structured in order:\n    // 1. Read state\n    // 2. Calculate required state mutations\n    // 3. Perform state mutations\n    push(element) {\n        const oldBack = this._back;\n        let newBack = oldBack;\n        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n            newBack = {\n                _elements: [],\n                _next: undefined\n            };\n        }\n        // push() is the mutation most likely to throw an exception, so it\n        // goes first.\n        oldBack._elements.push(element);\n        if (newBack !== oldBack) {\n            this._back = newBack;\n            oldBack._next = newBack;\n        }\n        ++this._size;\n    }\n    // Like push(), shift() follows the read -> calculate -> mutate pattern for\n    // exception safety.\n    shift() { // must not be called on an empty queue\n        const oldFront = this._front;\n        let newFront = oldFront;\n        const oldCursor = this._cursor;\n        let newCursor = oldCursor + 1;\n        const elements = oldFront._elements;\n        const element = elements[oldCursor];\n        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n            newFront = oldFront._next;\n            newCursor = 0;\n        }\n        // No mutations before this point.\n        --this._size;\n        this._cursor = newCursor;\n        if (oldFront !== newFront) {\n            this._front = newFront;\n        }\n        // Permit shifted element to be garbage collected.\n        elements[oldCursor] = undefined;\n        return element;\n    }\n    // The tricky thing about forEach() is that it can be called\n    // re-entrantly. The queue may be mutated inside the callback. It is easy to\n    // see that push() within the callback has no negative effects since the end\n    // of the queue is checked for on every iteration. If shift() is called\n    // repeatedly within the callback then the next iteration may return an\n    // element that has been removed. In this case the callback will be called\n    // with undefined values until we either \"catch up\" with elements that still\n    // exist or reach the back of the queue.\n    forEach(callback) {\n        let i = this._cursor;\n        let node = this._front;\n        let elements = node._elements;\n        while (i !== elements.length || node._next !== undefined) {\n            if (i === elements.length) {\n                node = node._next;\n                elements = node._elements;\n                i = 0;\n                if (elements.length === 0) {\n                    break;\n                }\n            }\n            callback(elements[i]);\n            ++i;\n        }\n    }\n    // Return the element that would be returned if shift() was called now,\n    // without modifying the queue.\n    peek() { // must not be called on an empty queue\n        const front = this._front;\n        const cursor = this._cursor;\n        return front._elements[cursor];\n    }\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n    reader._ownerReadableStream = stream;\n    stream._reader = reader;\n    if (stream._state === 'readable') {\n        defaultReaderClosedPromiseInitialize(reader);\n    }\n    else if (stream._state === 'closed') {\n        defaultReaderClosedPromiseInitializeAsResolved(reader);\n    }\n    else {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    }\n}\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n    const stream = reader._ownerReadableStream;\n    return ReadableStreamCancel(stream, reason);\n}\nfunction ReadableStreamReaderGenericRelease(reader) {\n    if (reader._ownerReadableStream._state === 'readable') {\n        defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    else {\n        defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    reader._ownerReadableStream._reader = undefined;\n    reader._ownerReadableStream = undefined;\n}\n// Helper functions for the readers.\nfunction readerLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderClosedPromiseInitialize(reader) {\n    reader._closedPromise = newPromise((resolve, reject) => {\n        reader._closedPromise_resolve = resolve;\n        reader._closedPromise_reject = reject;\n    });\n}\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseReject(reader, reason);\n}\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n    if (reader._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(reader._closedPromise);\n    reader._closedPromise_reject(reason);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\nfunction defaultReaderClosedPromiseResolve(reader) {\n    if (reader._closedPromise_resolve === undefined) {\n        return;\n    }\n    reader._closedPromise_resolve(undefined);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\n\nconst AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nconst ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\nconst CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nconst PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite = Number.isFinite || function (x) {\n    return typeof x === 'number' && isFinite(x);\n};\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc = Math.trunc || function (v) {\n    return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nfunction isDictionary(x) {\n    return typeof x === 'object' || typeof x === 'function';\n}\nfunction assertDictionary(obj, context) {\n    if (obj !== undefined && !isDictionary(obj)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-callback-functions\nfunction assertFunction(x, context) {\n    if (typeof x !== 'function') {\n        throw new TypeError(`${context} is not a function.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-object\nfunction isObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nfunction assertObject(x, context) {\n    if (!isObject(x)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\nfunction assertRequiredArgument(x, position, context) {\n    if (x === undefined) {\n        throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n    }\n}\nfunction assertRequiredField(x, field, context) {\n    if (x === undefined) {\n        throw new TypeError(`${field} is required in '${context}'.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nfunction convertUnrestrictedDouble(value) {\n    return Number(value);\n}\nfunction censorNegativeZero(x) {\n    return x === 0 ? 0 : x;\n}\nfunction integerPart(x) {\n    return censorNegativeZero(MathTrunc(x));\n}\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nfunction convertUnsignedLongLongWithEnforceRange(value, context) {\n    const lowerBound = 0;\n    const upperBound = Number.MAX_SAFE_INTEGER;\n    let x = Number(value);\n    x = censorNegativeZero(x);\n    if (!NumberIsFinite(x)) {\n        throw new TypeError(`${context} is not a finite number`);\n    }\n    x = integerPart(x);\n    if (x < lowerBound || x > upperBound) {\n        throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n    }\n    if (!NumberIsFinite(x) || x === 0) {\n        return 0;\n    }\n    // TODO Use BigInt if supported?\n    // let xBigInt = BigInt(integerPart(x));\n    // xBigInt = BigInt.asUintN(64, xBigInt);\n    // return Number(xBigInt);\n    return x;\n}\n\nfunction assertReadableStream(x, context) {\n    if (!IsReadableStream(x)) {\n        throw new TypeError(`${context} is not a ReadableStream.`);\n    }\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamDefaultReader(stream) {\n    return new ReadableStreamDefaultReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadRequest(stream, readRequest) {\n    stream._reader._readRequests.push(readRequest);\n}\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readRequest = reader._readRequests.shift();\n    if (done) {\n        readRequest._closeSteps();\n    }\n    else {\n        readRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadRequests(stream) {\n    return stream._reader._readRequests.length;\n}\nfunction ReadableStreamHasDefaultReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamDefaultReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamDefaultReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed,\n     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamDefaultReaderRead(this, readRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            throw defaultReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamDefaultReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n        return false;\n    }\n    return x instanceof ReadableStreamDefaultReader;\n}\nfunction ReadableStreamDefaultReaderRead(reader, readRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        readRequest._closeSteps();\n    }\n    else if (stream._state === 'errored') {\n        readRequest._errorSteps(stream._storedError);\n    }\n    else {\n        stream._readableStreamController[PullSteps](readRequest);\n    }\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\n/* eslint-disable @typescript-eslint/no-empty-function */\nconst AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);\n\n/// <reference lib=\"es2018.asynciterable\" />\nclass ReadableStreamAsyncIteratorImpl {\n    constructor(reader, preventCancel) {\n        this._ongoingPromise = undefined;\n        this._isFinished = false;\n        this._reader = reader;\n        this._preventCancel = preventCancel;\n    }\n    next() {\n        const nextSteps = () => this._nextSteps();\n        this._ongoingPromise = this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n            nextSteps();\n        return this._ongoingPromise;\n    }\n    return(value) {\n        const returnSteps = () => this._returnSteps(value);\n        return this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n            returnSteps();\n    }\n    _nextSteps() {\n        if (this._isFinished) {\n            return Promise.resolve({ value: undefined, done: true });\n        }\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('iterate'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => {\n                this._ongoingPromise = undefined;\n                // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                // FIXME Is this a bug in the specification, or in the test?\n                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n            },\n            _closeSteps: () => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                resolvePromise({ value: undefined, done: true });\n            },\n            _errorSteps: reason => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                rejectPromise(reason);\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promise;\n    }\n    _returnSteps(value) {\n        if (this._isFinished) {\n            return Promise.resolve({ value, done: true });\n        }\n        this._isFinished = true;\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('finish iterating'));\n        }\n        if (!this._preventCancel) {\n            const result = ReadableStreamReaderGenericCancel(reader, value);\n            ReadableStreamReaderGenericRelease(reader);\n            return transformPromiseWith(result, () => ({ value, done: true }));\n        }\n        ReadableStreamReaderGenericRelease(reader);\n        return promiseResolvedWith({ value, done: true });\n    }\n}\nconst ReadableStreamAsyncIteratorPrototype = {\n    next() {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        return this._asyncIteratorImpl.next();\n    },\n    return(value) {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n        }\n        return this._asyncIteratorImpl.return(value);\n    }\n};\nif (AsyncIteratorPrototype !== undefined) {\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n    iterator._asyncIteratorImpl = impl;\n    return iterator;\n}\nfunction IsReadableStreamAsyncIterator(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n        return false;\n    }\n    try {\n        // noinspection SuspiciousTypeOfGuard\n        return x._asyncIteratorImpl instanceof\n            ReadableStreamAsyncIteratorImpl;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n// Helper functions for the ReadableStream.\nfunction streamAsyncIteratorBrandCheckException(name) {\n    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n};\n\nfunction CreateArrayFromList(elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n}\nfunction CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n// Not implemented correctly\nfunction TransferArrayBuffer(O) {\n    return O;\n}\n// Not implemented correctly\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction IsDetachedBuffer(O) {\n    return false;\n}\nfunction ArrayBufferSlice(buffer, begin, end) {\n    // ArrayBuffer.prototype.slice is not available on IE10\n    // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n    if (buffer.slice) {\n        return buffer.slice(begin, end);\n    }\n    const length = end - begin;\n    const slice = new ArrayBuffer(length);\n    CopyDataBlockBytes(slice, 0, buffer, begin, length);\n    return slice;\n}\n\nfunction IsNonNegativeNumber(v) {\n    if (typeof v !== 'number') {\n        return false;\n    }\n    if (NumberIsNaN(v)) {\n        return false;\n    }\n    if (v < 0) {\n        return false;\n    }\n    return true;\n}\nfunction CloneAsUint8Array(O) {\n    const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n    return new Uint8Array(buffer);\n}\n\nfunction DequeueValue(container) {\n    const pair = container._queue.shift();\n    container._queueTotalSize -= pair.size;\n    if (container._queueTotalSize < 0) {\n        container._queueTotalSize = 0;\n    }\n    return pair.value;\n}\nfunction EnqueueValueWithSize(container, value, size) {\n    if (!IsNonNegativeNumber(size) || size === Infinity) {\n        throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n    }\n    container._queue.push({ value, size });\n    container._queueTotalSize += size;\n}\nfunction PeekQueueValue(container) {\n    const pair = container._queue.peek();\n    return pair.value;\n}\nfunction ResetQueue(container) {\n    container._queue = new SimpleQueue();\n    container._queueTotalSize = 0;\n}\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nclass ReadableStreamBYOBRequest {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n     */\n    get view() {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('view');\n        }\n        return this._view;\n    }\n    respond(bytesWritten) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        assertRequiredArgument(bytesWritten, 1, 'respond');\n        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(this._view.buffer)) ;\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n    }\n    respondWithNewView(view) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respondWithNewView');\n        }\n        assertRequiredArgument(view, 1, 'respondWithNewView');\n        if (!ArrayBuffer.isView(view)) {\n            throw new TypeError('You can only respond with array buffer views');\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(view.buffer)) ;\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n    respond: { enumerable: true },\n    respondWithNewView: { enumerable: true },\n    view: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBRequest',\n        configurable: true\n    });\n}\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableByteStreamController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the current BYOB pull request, or `null` if there isn't one.\n     */\n    get byobRequest() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('byobRequest');\n        }\n        return ReadableByteStreamControllerGetBYOBRequest(this);\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('desiredSize');\n        }\n        return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('close');\n        }\n        if (this._closeRequested) {\n            throw new TypeError('The stream has already been closed; do not close it again!');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n        }\n        ReadableByteStreamControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('enqueue');\n        }\n        assertRequiredArgument(chunk, 1, 'enqueue');\n        if (!ArrayBuffer.isView(chunk)) {\n            throw new TypeError('chunk must be an array buffer view');\n        }\n        if (chunk.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (chunk.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._closeRequested) {\n            throw new TypeError('stream is closed or draining');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n        }\n        ReadableByteStreamControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('error');\n        }\n        ReadableByteStreamControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ReadableByteStreamControllerClearPendingPullIntos(this);\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableByteStreamControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableByteStream;\n        if (this._queueTotalSize > 0) {\n            const entry = this._queue.shift();\n            this._queueTotalSize -= entry.byteLength;\n            ReadableByteStreamControllerHandleQueueDrain(this);\n            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n            readRequest._chunkSteps(view);\n            return;\n        }\n        const autoAllocateChunkSize = this._autoAllocateChunkSize;\n        if (autoAllocateChunkSize !== undefined) {\n            let buffer;\n            try {\n                buffer = new ArrayBuffer(autoAllocateChunkSize);\n            }\n            catch (bufferE) {\n                readRequest._errorSteps(bufferE);\n                return;\n            }\n            const pullIntoDescriptor = {\n                buffer,\n                bufferByteLength: autoAllocateChunkSize,\n                byteOffset: 0,\n                byteLength: autoAllocateChunkSize,\n                bytesFilled: 0,\n                elementSize: 1,\n                viewConstructor: Uint8Array,\n                readerType: 'default'\n            };\n            this._pendingPullIntos.push(pullIntoDescriptor);\n        }\n        ReadableStreamAddReadRequest(stream, readRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(this);\n    }\n}\nObject.defineProperties(ReadableByteStreamController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    byobRequest: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableByteStreamController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableByteStreamController.\nfunction IsReadableByteStreamController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n        return false;\n    }\n    return x instanceof ReadableByteStreamController;\n}\nfunction IsReadableStreamBYOBRequest(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n        return false;\n    }\n    return x instanceof ReadableStreamBYOBRequest;\n}\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    // TODO: Test controller argument\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableByteStreamControllerError(controller, e);\n    });\n}\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    controller._pendingPullIntos = new SimpleQueue();\n}\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n    let done = false;\n    if (stream._state === 'closed') {\n        done = true;\n    }\n    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    if (pullIntoDescriptor.readerType === 'default') {\n        ReadableStreamFulfillReadRequest(stream, filledView, done);\n    }\n    else {\n        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n    }\n}\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n    const bytesFilled = pullIntoDescriptor.bytesFilled;\n    const elementSize = pullIntoDescriptor.elementSize;\n    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n    controller._queue.push({ buffer, byteOffset, byteLength });\n    controller._queueTotalSize += byteLength;\n}\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n    const elementSize = pullIntoDescriptor.elementSize;\n    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n    let totalBytesToCopyRemaining = maxBytesToCopy;\n    let ready = false;\n    if (maxAlignedBytes > currentAlignedBytes) {\n        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n        ready = true;\n    }\n    const queue = controller._queue;\n    while (totalBytesToCopyRemaining > 0) {\n        const headOfQueue = queue.peek();\n        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n        if (headOfQueue.byteLength === bytesToCopy) {\n            queue.shift();\n        }\n        else {\n            headOfQueue.byteOffset += bytesToCopy;\n            headOfQueue.byteLength -= bytesToCopy;\n        }\n        controller._queueTotalSize -= bytesToCopy;\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n        totalBytesToCopyRemaining -= bytesToCopy;\n    }\n    return ready;\n}\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n    pullIntoDescriptor.bytesFilled += size;\n}\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n    if (controller._queueTotalSize === 0 && controller._closeRequested) {\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(controller._controlledReadableByteStream);\n    }\n    else {\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n}\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n    if (controller._byobRequest === null) {\n        return;\n    }\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\n    controller._byobRequest._view = null;\n    controller._byobRequest = null;\n}\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n    while (controller._pendingPullIntos.length > 0) {\n        if (controller._queueTotalSize === 0) {\n            return;\n        }\n        const pullIntoDescriptor = controller._pendingPullIntos.peek();\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n    const stream = controller._controlledReadableByteStream;\n    let elementSize = 1;\n    if (view.constructor !== DataView) {\n        elementSize = view.constructor.BYTES_PER_ELEMENT;\n    }\n    const ctor = view.constructor;\n    // try {\n    const buffer = TransferArrayBuffer(view.buffer);\n    // } catch (e) {\n    //   readIntoRequest._errorSteps(e);\n    //   return;\n    // }\n    const pullIntoDescriptor = {\n        buffer,\n        bufferByteLength: buffer.byteLength,\n        byteOffset: view.byteOffset,\n        byteLength: view.byteLength,\n        bytesFilled: 0,\n        elementSize,\n        viewConstructor: ctor,\n        readerType: 'byob'\n    };\n    if (controller._pendingPullIntos.length > 0) {\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n        // - No change happens on desiredSize\n        // - The source has already been notified of that there's at least 1 pending read(view)\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        return;\n    }\n    if (stream._state === 'closed') {\n        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n        readIntoRequest._closeSteps(emptyView);\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            ReadableByteStreamControllerHandleQueueDrain(controller);\n            readIntoRequest._chunkSteps(filledView);\n            return;\n        }\n        if (controller._closeRequested) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            readIntoRequest._errorSteps(e);\n            return;\n        }\n    }\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n    const stream = controller._controlledReadableByteStream;\n    if (ReadableStreamHasBYOBReader(stream)) {\n        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n        return;\n    }\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n    if (remainderSize > 0) {\n        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n    }\n    pullIntoDescriptor.bytesFilled -= remainderSize;\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        ReadableByteStreamControllerRespondInClosedState(controller);\n    }\n    else {\n        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n    const descriptor = controller._pendingPullIntos.shift();\n    return descriptor;\n}\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return false;\n    }\n    if (controller._closeRequested) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n}\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\nfunction ReadableByteStreamControllerClose(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        controller._closeRequested = true;\n        return;\n    }\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (firstPendingPullInto.bytesFilled > 0) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            throw e;\n        }\n    }\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n}\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    const buffer = chunk.buffer;\n    const byteOffset = chunk.byteOffset;\n    const byteLength = chunk.byteLength;\n    const transferredBuffer = TransferArrayBuffer(buffer);\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n        firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n    }\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    if (ReadableStreamHasDefaultReader(stream)) {\n        if (ReadableStreamGetNumReadRequests(stream) === 0) {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        else {\n            if (controller._pendingPullIntos.length > 0) {\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n            }\n            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, false);\n        }\n    }\n    else if (ReadableStreamHasBYOBReader(stream)) {\n        // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    else {\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerError(controller, e) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\n    ResetQueue(controller);\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableByteStreamControllerGetBYOBRequest(controller) {\n    if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n        const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n        SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n        controller._byobRequest = byobRequest;\n    }\n    return controller._byobRequest;\n}\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        if (bytesWritten !== 0) {\n            throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n        }\n    }\n    else {\n        if (bytesWritten === 0) {\n            throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n        }\n        if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n            throw new RangeError('bytesWritten out of range');\n        }\n    }\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        if (view.byteLength !== 0) {\n            throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n        }\n    }\n    else {\n        if (view.byteLength === 0) {\n            throw new TypeError('The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');\n        }\n    }\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n        throw new RangeError('The region specified by view does not match byobRequest');\n    }\n    if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n        throw new RangeError('The buffer of view has different capacity than byobRequest');\n    }\n    if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n        throw new RangeError('The region specified by view is larger than byobRequest');\n    }\n    const viewByteLength = view.byteLength;\n    firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n    ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n}\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n    controller._controlledReadableByteStream = stream;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._byobRequest = null;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._closeRequested = false;\n    controller._started = false;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    controller._autoAllocateChunkSize = autoAllocateChunkSize;\n    controller._pendingPullIntos = new SimpleQueue();\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableByteStreamControllerError(controller, r);\n    });\n}\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingByteSource.start !== undefined) {\n        startAlgorithm = () => underlyingByteSource.start(controller);\n    }\n    if (underlyingByteSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingByteSource.pull(controller);\n    }\n    if (underlyingByteSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingByteSource.cancel(reason);\n    }\n    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n    if (autoAllocateChunkSize === 0) {\n        throw new TypeError('autoAllocateChunkSize must be greater than 0');\n    }\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n    request._associatedReadableByteStreamController = controller;\n    request._view = view;\n}\n// Helper functions for the ReadableStreamBYOBRequest.\nfunction byobRequestBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n// Helper functions for the ReadableByteStreamController.\nfunction byteStreamControllerBrandCheckException(name) {\n    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamBYOBReader(stream) {\n    return new ReadableStreamBYOBReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n    stream._reader._readIntoRequests.push(readIntoRequest);\n}\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readIntoRequest = reader._readIntoRequests.shift();\n    if (done) {\n        readIntoRequest._closeSteps(chunk);\n    }\n    else {\n        readIntoRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n    return stream._reader._readIntoRequests.length;\n}\nfunction ReadableStreamHasBYOBReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamBYOBReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamBYOBReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        if (!IsReadableByteStreamController(stream._readableStreamController)) {\n            throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                'source');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readIntoRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Attempts to reads bytes into view, and returns a promise resolved with the result.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read(view) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('read'));\n        }\n        if (!ArrayBuffer.isView(view)) {\n            return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n        }\n        if (view.byteLength === 0) {\n            return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n        }\n        if (view.buffer.byteLength === 0) {\n            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n        }\n        if (IsDetachedBuffer(view.buffer)) ;\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readIntoRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            throw byobReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readIntoRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamBYOBReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n        return false;\n    }\n    return x instanceof ReadableStreamBYOBReader;\n}\nfunction ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'errored') {\n        readIntoRequest._errorSteps(stream._storedError);\n    }\n    else {\n        ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n    }\n}\n// Helper functions for the ReadableStreamBYOBReader.\nfunction byobReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\nfunction ExtractHighWaterMark(strategy, defaultHWM) {\n    const { highWaterMark } = strategy;\n    if (highWaterMark === undefined) {\n        return defaultHWM;\n    }\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n        throw new RangeError('Invalid highWaterMark');\n    }\n    return highWaterMark;\n}\nfunction ExtractSizeAlgorithm(strategy) {\n    const { size } = strategy;\n    if (!size) {\n        return () => 1;\n    }\n    return size;\n}\n\nfunction convertQueuingStrategy(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    const size = init === null || init === void 0 ? void 0 : init.size;\n    return {\n        highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n        size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n    };\n}\nfunction convertQueuingStrategySize(fn, context) {\n    assertFunction(fn, context);\n    return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n\nfunction convertUnderlyingSink(original, context) {\n    assertDictionary(original, context);\n    const abort = original === null || original === void 0 ? void 0 : original.abort;\n    const close = original === null || original === void 0 ? void 0 : original.close;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    const write = original === null || original === void 0 ? void 0 : original.write;\n    return {\n        abort: abort === undefined ?\n            undefined :\n            convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n        close: close === undefined ?\n            undefined :\n            convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n        write: write === undefined ?\n            undefined :\n            convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n        type\n    };\n}\nfunction convertUnderlyingSinkAbortCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSinkCloseCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return () => promiseCall(fn, original, []);\n}\nfunction convertUnderlyingSinkStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSinkWriteCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction assertWritableStream(x, context) {\n    if (!IsWritableStream(x)) {\n        throw new TypeError(`${context} is not a WritableStream.`);\n    }\n}\n\nfunction isAbortSignal(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        return typeof value.aborted === 'boolean';\n    }\n    catch (_a) {\n        // AbortSignal.prototype.aborted throws if its brand check fails\n        return false;\n    }\n}\nconst supportsAbortController = typeof AbortController === 'function';\n/**\n * Construct a new AbortController, if supported by the platform.\n *\n * @internal\n */\nfunction createAbortController() {\n    if (supportsAbortController) {\n        return new AbortController();\n    }\n    return undefined;\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream {\n    constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n        if (rawUnderlyingSink === undefined) {\n            rawUnderlyingSink = null;\n        }\n        else {\n            assertObject(rawUnderlyingSink, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n        InitializeWritableStream(this);\n        const type = underlyingSink.type;\n        if (type !== undefined) {\n            throw new RangeError('Invalid type is specified');\n        }\n        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n        const highWaterMark = ExtractHighWaterMark(strategy, 1);\n        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n    }\n    /**\n     * Returns whether or not the writable stream is locked to a writer.\n     */\n    get locked() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('locked');\n        }\n        return IsWritableStreamLocked(this);\n    }\n    /**\n     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n     * mechanism of the underlying sink.\n     *\n     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n     * the stream) if the stream is currently locked.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('abort'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n        }\n        return WritableStreamAbort(this, reason);\n    }\n    /**\n     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n     * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n     *\n     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n     */\n    close() {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('close'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamClose(this);\n    }\n    /**\n     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n     * is locked, no other writer can be acquired until this one is released.\n     *\n     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n     */\n    getWriter() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('getWriter');\n        }\n        return AcquireWritableStreamDefaultWriter(this);\n    }\n}\nObject.defineProperties(WritableStream.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    getWriter: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStream',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStream.\nfunction AcquireWritableStreamDefaultWriter(stream) {\n    return new WritableStreamDefaultWriter(stream);\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(WritableStream.prototype);\n    InitializeWritableStream(stream);\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeWritableStream(stream) {\n    stream._state = 'writable';\n    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n    // 'erroring' or 'errored'. May be set to an undefined value.\n    stream._storedError = undefined;\n    stream._writer = undefined;\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    stream._writableStreamController = undefined;\n    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n    stream._writeRequests = new SimpleQueue();\n    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n    stream._inFlightWriteRequest = undefined;\n    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n    stream._closeRequest = undefined;\n    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n    stream._inFlightCloseRequest = undefined;\n    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n    stream._pendingAbortRequest = undefined;\n    // The backpressure signal set by the controller.\n    stream._backpressure = false;\n}\nfunction IsWritableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n        return false;\n    }\n    return x instanceof WritableStream;\n}\nfunction IsWritableStreamLocked(stream) {\n    if (stream._writer === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamAbort(stream, reason) {\n    var _a;\n    if (stream._state === 'closed' || stream._state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    stream._writableStreamController._abortReason = reason;\n    (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n    // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n    // but it doesn't know that signaling abort runs author code that might have changed the state.\n    // Widen the type again by casting to WritableStreamState.\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._pendingAbortRequest !== undefined) {\n        return stream._pendingAbortRequest._promise;\n    }\n    let wasAlreadyErroring = false;\n    if (state === 'erroring') {\n        wasAlreadyErroring = true;\n        // reason will not be used, so don't keep a reference to it.\n        reason = undefined;\n    }\n    const promise = newPromise((resolve, reject) => {\n        stream._pendingAbortRequest = {\n            _promise: undefined,\n            _resolve: resolve,\n            _reject: reject,\n            _reason: reason,\n            _wasAlreadyErroring: wasAlreadyErroring\n        };\n    });\n    stream._pendingAbortRequest._promise = promise;\n    if (!wasAlreadyErroring) {\n        WritableStreamStartErroring(stream, reason);\n    }\n    return promise;\n}\nfunction WritableStreamClose(stream) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n    }\n    const promise = newPromise((resolve, reject) => {\n        const closeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._closeRequest = closeRequest;\n    });\n    const writer = stream._writer;\n    if (writer !== undefined && stream._backpressure && state === 'writable') {\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\n    return promise;\n}\n// WritableStream API exposed for controllers.\nfunction WritableStreamAddWriteRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const writeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._writeRequests.push(writeRequest);\n    });\n    return promise;\n}\nfunction WritableStreamDealWithRejection(stream, error) {\n    const state = stream._state;\n    if (state === 'writable') {\n        WritableStreamStartErroring(stream, error);\n        return;\n    }\n    WritableStreamFinishErroring(stream);\n}\nfunction WritableStreamStartErroring(stream, reason) {\n    const controller = stream._writableStreamController;\n    stream._state = 'erroring';\n    stream._storedError = reason;\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n    }\n    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n        WritableStreamFinishErroring(stream);\n    }\n}\nfunction WritableStreamFinishErroring(stream) {\n    stream._state = 'errored';\n    stream._writableStreamController[ErrorSteps]();\n    const storedError = stream._storedError;\n    stream._writeRequests.forEach(writeRequest => {\n        writeRequest._reject(storedError);\n    });\n    stream._writeRequests = new SimpleQueue();\n    if (stream._pendingAbortRequest === undefined) {\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const abortRequest = stream._pendingAbortRequest;\n    stream._pendingAbortRequest = undefined;\n    if (abortRequest._wasAlreadyErroring) {\n        abortRequest._reject(storedError);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n    uponPromise(promise, () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }, (reason) => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\nfunction WritableStreamFinishInFlightWrite(stream) {\n    stream._inFlightWriteRequest._resolve(undefined);\n    stream._inFlightWriteRequest = undefined;\n}\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n    stream._inFlightWriteRequest._reject(error);\n    stream._inFlightWriteRequest = undefined;\n    WritableStreamDealWithRejection(stream, error);\n}\nfunction WritableStreamFinishInFlightClose(stream) {\n    stream._inFlightCloseRequest._resolve(undefined);\n    stream._inFlightCloseRequest = undefined;\n    const state = stream._state;\n    if (state === 'erroring') {\n        // The error was too late to do anything, so it is ignored.\n        stream._storedError = undefined;\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._resolve();\n            stream._pendingAbortRequest = undefined;\n        }\n    }\n    stream._state = 'closed';\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseResolve(writer);\n    }\n}\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n    stream._inFlightCloseRequest._reject(error);\n    stream._inFlightCloseRequest = undefined;\n    // Never execute sink abort() after sink close().\n    if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(error);\n        stream._pendingAbortRequest = undefined;\n    }\n    WritableStreamDealWithRejection(stream, error);\n}\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n    stream._inFlightCloseRequest = stream._closeRequest;\n    stream._closeRequest = undefined;\n}\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n    if (stream._closeRequest !== undefined) {\n        stream._closeRequest._reject(stream._storedError);\n        stream._closeRequest = undefined;\n    }\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseReject(writer, stream._storedError);\n    }\n}\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n    const writer = stream._writer;\n    if (writer !== undefined && backpressure !== stream._backpressure) {\n        if (backpressure) {\n            defaultWriterReadyPromiseReset(writer);\n        }\n        else {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n    }\n    stream._backpressure = backpressure;\n}\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nclass WritableStreamDefaultWriter {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n        assertWritableStream(stream, 'First parameter');\n        if (IsWritableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n        }\n        this._ownerWritableStream = stream;\n        stream._writer = this;\n        const state = stream._state;\n        if (state === 'writable') {\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                defaultWriterReadyPromiseInitialize(this);\n            }\n            else {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n            }\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'erroring') {\n            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'closed') {\n            defaultWriterReadyPromiseInitializeAsResolved(this);\n            defaultWriterClosedPromiseInitializeAsResolved(this);\n        }\n        else {\n            const storedError = stream._storedError;\n            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n        }\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the writers lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n     * A producer can use this information to determine the right amount of data to write.\n     *\n     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n     * the writers lock is released.\n     */\n    get desiredSize() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('desiredSize');\n        }\n        if (this._ownerWritableStream === undefined) {\n            throw defaultWriterLockException('desiredSize');\n        }\n        return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n    /**\n     * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n     * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n     *\n     * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n     * rejected.\n     */\n    get ready() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n        }\n        return this._readyPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('abort'));\n        }\n        return WritableStreamDefaultWriterAbort(this, reason);\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n     */\n    close() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('close'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamDefaultWriterClose(this);\n    }\n    /**\n     * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n     * now on; otherwise, the writer will appear closed.\n     *\n     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n     * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n     * other producers from writing in an interleaved manner.\n     */\n    releaseLock() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('releaseLock');\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return;\n        }\n        WritableStreamDefaultWriterRelease(this);\n    }\n    write(chunk = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        return WritableStreamDefaultWriterWrite(this, chunk);\n    }\n}\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    releaseLock: { enumerable: true },\n    write: { enumerable: true },\n    closed: { enumerable: true },\n    desiredSize: { enumerable: true },\n    ready: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultWriter',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStreamDefaultWriter.\nfunction IsWritableStreamDefaultWriter(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n        return false;\n    }\n    return x instanceof WritableStreamDefaultWriter;\n}\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamAbort(stream, reason);\n}\nfunction WritableStreamDefaultWriterClose(writer) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamClose(stream);\n}\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return WritableStreamDefaultWriterClose(writer);\n}\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n    if (writer._closedPromiseState === 'pending') {\n        defaultWriterClosedPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterClosedPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n    if (writer._readyPromiseState === 'pending') {\n        defaultWriterReadyPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterReadyPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (state === 'errored' || state === 'erroring') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\nfunction WritableStreamDefaultWriterRelease(writer) {\n    const stream = writer._ownerWritableStream;\n    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n    // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n    // rejected until afterwards. This means that simply testing state will not work.\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n    stream._writer = undefined;\n    writer._ownerWritableStream = undefined;\n}\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n    const stream = writer._ownerWritableStream;\n    const controller = stream._writableStreamController;\n    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n    if (stream !== writer._ownerWritableStream) {\n        return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n    const state = stream._state;\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n    }\n    if (state === 'erroring') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    const promise = WritableStreamAddWriteRequest(stream);\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n    return promise;\n}\nconst closeSentinel = {};\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nclass WritableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n     *\n     * @deprecated\n     *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n     *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n     */\n    get abortReason() {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$2('abortReason');\n        }\n        return this._abortReason;\n    }\n    /**\n     * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n     */\n    get signal() {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$2('signal');\n        }\n        if (this._abortController === undefined) {\n            // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n            // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n            // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n            throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n        }\n        return this._abortController.signal;\n    }\n    /**\n     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n     *\n     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n     * normal lifecycle of interactions with the underlying sink.\n     */\n    error(e = undefined) {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$2('error');\n        }\n        const state = this._controlledWritableStream._state;\n        if (state !== 'writable') {\n            // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n            // just treat it as a no-op.\n            return;\n        }\n        WritableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [AbortSteps](reason) {\n        const result = this._abortAlgorithm(reason);\n        WritableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [ErrorSteps]() {\n        ResetQueue(this);\n    }\n}\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n    abortReason: { enumerable: true },\n    signal: { enumerable: true },\n    error: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations implementing interface required by the WritableStream.\nfunction IsWritableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n        return false;\n    }\n    return x instanceof WritableStreamDefaultController;\n}\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledWritableStream = stream;\n    stream._writableStreamController = controller;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._abortReason = undefined;\n    controller._abortController = createAbortController();\n    controller._started = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._writeAlgorithm = writeAlgorithm;\n    controller._closeAlgorithm = closeAlgorithm;\n    controller._abortAlgorithm = abortAlgorithm;\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n    const startResult = startAlgorithm();\n    const startPromise = promiseResolvedWith(startResult);\n    uponPromise(startPromise, () => {\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, r => {\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n    });\n}\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let writeAlgorithm = () => promiseResolvedWith(undefined);\n    let closeAlgorithm = () => promiseResolvedWith(undefined);\n    let abortAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSink.start !== undefined) {\n        startAlgorithm = () => underlyingSink.start(controller);\n    }\n    if (underlyingSink.write !== undefined) {\n        writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n    }\n    if (underlyingSink.close !== undefined) {\n        closeAlgorithm = () => underlyingSink.close();\n    }\n    if (underlyingSink.abort !== undefined) {\n        abortAlgorithm = reason => underlyingSink.abort(reason);\n    }\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._writeAlgorithm = undefined;\n    controller._closeAlgorithm = undefined;\n    controller._abortAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\nfunction WritableStreamDefaultControllerClose(controller) {\n    EnqueueValueWithSize(controller, closeSentinel, 0);\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n    try {\n        return controller._strategySizeAlgorithm(chunk);\n    }\n    catch (chunkSizeE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n        return 1;\n    }\n}\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n    try {\n        EnqueueValueWithSize(controller, chunk, chunkSize);\n    }\n    catch (enqueueE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n        return;\n    }\n    const stream = controller._controlledWritableStream;\n    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n// Abstract operations for the WritableStreamDefaultController.\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n    const stream = controller._controlledWritableStream;\n    if (!controller._started) {\n        return;\n    }\n    if (stream._inFlightWriteRequest !== undefined) {\n        return;\n    }\n    const state = stream._state;\n    if (state === 'erroring') {\n        WritableStreamFinishErroring(stream);\n        return;\n    }\n    if (controller._queue.length === 0) {\n        return;\n    }\n    const value = PeekQueueValue(controller);\n    if (value === closeSentinel) {\n        WritableStreamDefaultControllerProcessClose(controller);\n    }\n    else {\n        WritableStreamDefaultControllerProcessWrite(controller, value);\n    }\n}\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n    if (controller._controlledWritableStream._state === 'writable') {\n        WritableStreamDefaultControllerError(controller, error);\n    }\n}\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkCloseRequestInFlight(stream);\n    DequeueValue(controller);\n    const sinkClosePromise = controller._closeAlgorithm();\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    uponPromise(sinkClosePromise, () => {\n        WritableStreamFinishInFlightClose(stream);\n    }, reason => {\n        WritableStreamFinishInFlightCloseWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\n    const sinkWritePromise = controller._writeAlgorithm(chunk);\n    uponPromise(sinkWritePromise, () => {\n        WritableStreamFinishInFlightWrite(stream);\n        const state = stream._state;\n        DequeueValue(controller);\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, reason => {\n        if (stream._state === 'writable') {\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n        }\n        WritableStreamFinishInFlightWriteWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n    return desiredSize <= 0;\n}\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\nfunction WritableStreamDefaultControllerError(controller, error) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    WritableStreamStartErroring(stream, error);\n}\n// Helper functions for the WritableStream.\nfunction streamBrandCheckException$2(name) {\n    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n// Helper functions for the WritableStreamDefaultController.\nfunction defaultControllerBrandCheckException$2(name) {\n    return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n}\n// Helper functions for the WritableStreamDefaultWriter.\nfunction defaultWriterBrandCheckException(name) {\n    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\nfunction defaultWriterLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\nfunction defaultWriterClosedPromiseInitialize(writer) {\n    writer._closedPromise = newPromise((resolve, reject) => {\n        writer._closedPromise_resolve = resolve;\n        writer._closedPromise_reject = reject;\n        writer._closedPromiseState = 'pending';\n    });\n}\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseReject(writer, reason);\n}\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseResolve(writer);\n}\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n    if (writer._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._closedPromise);\n    writer._closedPromise_reject(reason);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'rejected';\n}\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterClosedPromiseResolve(writer) {\n    if (writer._closedPromise_resolve === undefined) {\n        return;\n    }\n    writer._closedPromise_resolve(undefined);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'resolved';\n}\nfunction defaultWriterReadyPromiseInitialize(writer) {\n    writer._readyPromise = newPromise((resolve, reject) => {\n        writer._readyPromise_resolve = resolve;\n        writer._readyPromise_reject = reject;\n    });\n    writer._readyPromiseState = 'pending';\n}\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseReject(writer, reason);\n}\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseResolve(writer);\n}\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n    if (writer._readyPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._readyPromise);\n    writer._readyPromise_reject(reason);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'rejected';\n}\nfunction defaultWriterReadyPromiseReset(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n}\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterReadyPromiseResolve(writer) {\n    if (writer._readyPromise_resolve === undefined) {\n        return;\n    }\n    writer._readyPromise_resolve(undefined);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'fulfilled';\n}\n\n/// <reference lib=\"dom\" />\nconst NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n/// <reference types=\"node\" />\nfunction isDOMExceptionConstructor(ctor) {\n    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n        return false;\n    }\n    try {\n        new ctor();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction createDOMExceptionPolyfill() {\n    // eslint-disable-next-line no-shadow\n    const ctor = function DOMException(message, name) {\n        this.message = message || '';\n        this.name = name || 'Error';\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    };\n    ctor.prototype = Object.create(Error.prototype);\n    Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n    return ctor;\n}\n// eslint-disable-next-line no-redeclare\nconst DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n    const reader = AcquireReadableStreamDefaultReader(source);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n    source._disturbed = true;\n    let shuttingDown = false;\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = promiseResolvedWith(undefined);\n    return newPromise((resolve, reject) => {\n        let abortAlgorithm;\n        if (signal !== undefined) {\n            abortAlgorithm = () => {\n                const error = new DOMException$1('Aborted', 'AbortError');\n                const actions = [];\n                if (!preventAbort) {\n                    actions.push(() => {\n                        if (dest._state === 'writable') {\n                            return WritableStreamAbort(dest, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                if (!preventCancel) {\n                    actions.push(() => {\n                        if (source._state === 'readable') {\n                            return ReadableStreamCancel(source, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n            };\n            if (signal.aborted) {\n                abortAlgorithm();\n                return;\n            }\n            signal.addEventListener('abort', abortAlgorithm);\n        }\n        // Using reader and writer, read all chunks from this and write them to dest\n        // - Backpressure must be enforced\n        // - Shutdown must stop all activity\n        function pipeLoop() {\n            return newPromise((resolveLoop, rejectLoop) => {\n                function next(done) {\n                    if (done) {\n                        resolveLoop();\n                    }\n                    else {\n                        // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                        // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                        PerformPromiseThen(pipeStep(), next, rejectLoop);\n                    }\n                }\n                next(false);\n            });\n        }\n        function pipeStep() {\n            if (shuttingDown) {\n                return promiseResolvedWith(true);\n            }\n            return PerformPromiseThen(writer._readyPromise, () => {\n                return newPromise((resolveRead, rejectRead) => {\n                    ReadableStreamDefaultReaderRead(reader, {\n                        _chunkSteps: chunk => {\n                            currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                            resolveRead(false);\n                        },\n                        _closeSteps: () => resolveRead(true),\n                        _errorSteps: rejectRead\n                    });\n                });\n            });\n        }\n        // Errors must be propagated forward\n        isOrBecomesErrored(source, reader._closedPromise, storedError => {\n            if (!preventAbort) {\n                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Errors must be propagated backward\n        isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Closing must be propagated forward\n        isOrBecomesClosed(source, reader._closedPromise, () => {\n            if (!preventClose) {\n                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n            }\n            else {\n                shutdown();\n            }\n        });\n        // Closing must be propagated backward\n        if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n            const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n            }\n            else {\n                shutdown(true, destClosed);\n            }\n        }\n        setPromiseIsHandledToTrue(pipeLoop());\n        function waitForWritesToFinish() {\n            // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n            // for that too.\n            const oldCurrentWrite = currentWrite;\n            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n        }\n        function isOrBecomesErrored(stream, promise, action) {\n            if (stream._state === 'errored') {\n                action(stream._storedError);\n            }\n            else {\n                uponRejection(promise, action);\n            }\n        }\n        function isOrBecomesClosed(stream, promise, action) {\n            if (stream._state === 'closed') {\n                action();\n            }\n            else {\n                uponFulfillment(promise, action);\n            }\n        }\n        function shutdownWithAction(action, originalIsError, originalError) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), doTheRest);\n            }\n            else {\n                doTheRest();\n            }\n            function doTheRest() {\n                uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n            }\n        }\n        function shutdown(isError, error) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n            }\n            else {\n                finalize(isError, error);\n            }\n        }\n        function finalize(isError, error) {\n            WritableStreamDefaultWriterRelease(writer);\n            ReadableStreamReaderGenericRelease(reader);\n            if (signal !== undefined) {\n                signal.removeEventListener('abort', abortAlgorithm);\n            }\n            if (isError) {\n                reject(error);\n            }\n            else {\n                resolve(undefined);\n            }\n        }\n    });\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('desiredSize');\n        }\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('close');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits close');\n        }\n        ReadableStreamDefaultControllerClose(this);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('enqueue');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits enqueue');\n        }\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('error');\n        }\n        ReadableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableStream;\n        if (this._queue.length > 0) {\n            const chunk = DequeueValue(this);\n            if (this._closeRequested && this._queue.length === 0) {\n                ReadableStreamDefaultControllerClearAlgorithms(this);\n                ReadableStreamClose(stream);\n            }\n            else {\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n            readRequest._chunkSteps(chunk);\n        }\n        else {\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n        }\n    }\n}\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStreamDefaultController.\nfunction IsReadableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n        return false;\n    }\n    return x instanceof ReadableStreamDefaultController;\n}\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableStreamDefaultControllerError(controller, e);\n    });\n}\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableStream;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\nfunction ReadableStreamDefaultControllerClose(controller) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    controller._closeRequested = true;\n    if (controller._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n}\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        ReadableStreamFulfillReadRequest(stream, chunk, false);\n    }\n    else {\n        let chunkSize;\n        try {\n            chunkSize = controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            ReadableStreamDefaultControllerError(controller, chunkSizeE);\n            throw chunkSizeE;\n        }\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            ReadableStreamDefaultControllerError(controller, enqueueE);\n            throw enqueueE;\n        }\n    }\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction ReadableStreamDefaultControllerError(controller, e) {\n    const stream = controller._controlledReadableStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ResetQueue(controller);\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (!controller._closeRequested && state === 'readable') {\n        return true;\n    }\n    return false;\n}\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledReadableStream = stream;\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._closeRequested = false;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableStreamDefaultControllerError(controller, r);\n    });\n}\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSource.start !== undefined) {\n        startAlgorithm = () => underlyingSource.start(controller);\n    }\n    if (underlyingSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingSource.pull(controller);\n    }\n    if (underlyingSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingSource.cancel(reason);\n    }\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// Helper functions for the ReadableStreamDefaultController.\nfunction defaultControllerBrandCheckException$1(name) {\n    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n    if (IsReadableByteStreamController(stream._readableStreamController)) {\n        return ReadableByteStreamTee(stream);\n    }\n    return ReadableStreamDefaultTee(stream);\n}\nfunction ReadableStreamDefaultTee(stream, cloneForBranch2) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let readAgain = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function pullAlgorithm() {\n        if (reading) {\n            readAgain = true;\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const readRequest = {\n            _chunkSteps: chunk => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    readAgain = false;\n                    const chunk1 = chunk;\n                    const chunk2 = chunk;\n                    // There is no way to access the cloning code right now in the reference implementation.\n                    // If we add one then we'll need an implementation for serializable objects.\n                    // if (!canceled2 && cloneForBranch2) {\n                    //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                    // }\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                    }\n                    reading = false;\n                    if (readAgain) {\n                        pullAlgorithm();\n                    }\n                });\n            },\n            _closeSteps: () => {\n                reading = false;\n                if (!canceled1) {\n                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                }\n                if (!canceled2) {\n                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                }\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() {\n        // do nothing\n    }\n    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n    uponRejection(reader._closedPromise, (r) => {\n        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n        if (!canceled1 || !canceled2) {\n            resolveCancelPromise(undefined);\n        }\n    });\n    return [branch1, branch2];\n}\nfunction ReadableByteStreamTee(stream) {\n    let reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let readAgainForBranch1 = false;\n    let readAgainForBranch2 = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function forwardReaderError(thisReader) {\n        uponRejection(thisReader._closedPromise, r => {\n            if (thisReader !== reader) {\n                return;\n            }\n            ReadableByteStreamControllerError(branch1._readableStreamController, r);\n            ReadableByteStreamControllerError(branch2._readableStreamController, r);\n            if (!canceled1 || !canceled2) {\n                resolveCancelPromise(undefined);\n            }\n        });\n    }\n    function pullWithDefaultReader() {\n        if (IsReadableStreamBYOBReader(reader)) {\n            ReadableStreamReaderGenericRelease(reader);\n            reader = AcquireReadableStreamDefaultReader(stream);\n            forwardReaderError(reader);\n        }\n        const readRequest = {\n            _chunkSteps: chunk => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    readAgainForBranch1 = false;\n                    readAgainForBranch2 = false;\n                    const chunk1 = chunk;\n                    let chunk2 = chunk;\n                    if (!canceled1 && !canceled2) {\n                        try {\n                            chunk2 = CloneAsUint8Array(chunk);\n                        }\n                        catch (cloneE) {\n                            ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                            ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                            resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                            return;\n                        }\n                    }\n                    if (!canceled1) {\n                        ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                    }\n                    if (!canceled2) {\n                        ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                    }\n                    reading = false;\n                    if (readAgainForBranch1) {\n                        pull1Algorithm();\n                    }\n                    else if (readAgainForBranch2) {\n                        pull2Algorithm();\n                    }\n                });\n            },\n            _closeSteps: () => {\n                reading = false;\n                if (!canceled1) {\n                    ReadableByteStreamControllerClose(branch1._readableStreamController);\n                }\n                if (!canceled2) {\n                    ReadableByteStreamControllerClose(branch2._readableStreamController);\n                }\n                if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                }\n                if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                }\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n    }\n    function pullWithBYOBReader(view, forBranch2) {\n        if (IsReadableStreamDefaultReader(reader)) {\n            ReadableStreamReaderGenericRelease(reader);\n            reader = AcquireReadableStreamBYOBReader(stream);\n            forwardReaderError(reader);\n        }\n        const byobBranch = forBranch2 ? branch2 : branch1;\n        const otherBranch = forBranch2 ? branch1 : branch2;\n        const readIntoRequest = {\n            _chunkSteps: chunk => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    readAgainForBranch1 = false;\n                    readAgainForBranch2 = false;\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                    if (!otherCanceled) {\n                        let clonedChunk;\n                        try {\n                            clonedChunk = CloneAsUint8Array(chunk);\n                        }\n                        catch (cloneE) {\n                            ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                            ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                            resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                            return;\n                        }\n                        if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                    }\n                    else if (!byobCanceled) {\n                        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                    }\n                    reading = false;\n                    if (readAgainForBranch1) {\n                        pull1Algorithm();\n                    }\n                    else if (readAgainForBranch2) {\n                        pull2Algorithm();\n                    }\n                });\n            },\n            _closeSteps: chunk => {\n                reading = false;\n                const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                if (!byobCanceled) {\n                    ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                }\n                if (!otherCanceled) {\n                    ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                }\n                if (chunk !== undefined) {\n                    if (!byobCanceled) {\n                        ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                    }\n                    if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                    }\n                }\n                if (!byobCanceled || !otherCanceled) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n    }\n    function pull1Algorithm() {\n        if (reading) {\n            readAgainForBranch1 = true;\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n        if (byobRequest === null) {\n            pullWithDefaultReader();\n        }\n        else {\n            pullWithBYOBReader(byobRequest._view, false);\n        }\n        return promiseResolvedWith(undefined);\n    }\n    function pull2Algorithm() {\n        if (reading) {\n            readAgainForBranch2 = true;\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n        if (byobRequest === null) {\n            pullWithDefaultReader();\n        }\n        else {\n            pullWithBYOBReader(byobRequest._view, true);\n        }\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() {\n        return;\n    }\n    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n    forwardReaderError(reader);\n    return [branch1, branch2];\n}\n\nfunction convertUnderlyingDefaultOrByteSource(source, context) {\n    assertDictionary(source, context);\n    const original = source;\n    const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n    const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n    const pull = original === null || original === void 0 ? void 0 : original.pull;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    return {\n        autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n            undefined :\n            convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n        cancel: cancel === undefined ?\n            undefined :\n            convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n        pull: pull === undefined ?\n            undefined :\n            convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n        type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n    };\n}\nfunction convertUnderlyingSourceCancelCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSourcePullCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSourceStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertReadableStreamType(type, context) {\n    type = `${type}`;\n    if (type !== 'bytes') {\n        throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n    }\n    return type;\n}\n\nfunction convertReaderOptions(options, context) {\n    assertDictionary(options, context);\n    const mode = options === null || options === void 0 ? void 0 : options.mode;\n    return {\n        mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n    };\n}\nfunction convertReadableStreamReaderMode(mode, context) {\n    mode = `${mode}`;\n    if (mode !== 'byob') {\n        throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n    }\n    return mode;\n}\n\nfunction convertIteratorOptions(options, context) {\n    assertDictionary(options, context);\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    return { preventCancel: Boolean(preventCancel) };\n}\n\nfunction convertPipeOptions(options, context) {\n    assertDictionary(options, context);\n    const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal !== undefined) {\n        assertAbortSignal(signal, `${context} has member 'signal' that`);\n    }\n    return {\n        preventAbort: Boolean(preventAbort),\n        preventCancel: Boolean(preventCancel),\n        preventClose: Boolean(preventClose),\n        signal\n    };\n}\nfunction assertAbortSignal(signal, context) {\n    if (!isAbortSignal(signal)) {\n        throw new TypeError(`${context} is not an AbortSignal.`);\n    }\n}\n\nfunction convertReadableWritablePair(pair, context) {\n    assertDictionary(pair, context);\n    const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n    assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n    assertReadableStream(readable, `${context} has member 'readable' that`);\n    const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n    assertWritableStream(writable, `${context} has member 'writable' that`);\n    return { readable, writable };\n}\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nclass ReadableStream {\n    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n        if (rawUnderlyingSource === undefined) {\n            rawUnderlyingSource = null;\n        }\n        else {\n            assertObject(rawUnderlyingSource, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n        InitializeReadableStream(this);\n        if (underlyingSource.type === 'bytes') {\n            if (strategy.size !== undefined) {\n                throw new RangeError('The strategy for a byte stream cannot have a size function');\n            }\n            const highWaterMark = ExtractHighWaterMark(strategy, 0);\n            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n        }\n        else {\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n        }\n    }\n    /**\n     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n     */\n    get locked() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('locked');\n        }\n        return IsReadableStreamLocked(this);\n    }\n    /**\n     * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n     *\n     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n     * method, which might or might not use it.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n        }\n        return ReadableStreamCancel(this, reason);\n    }\n    getReader(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('getReader');\n        }\n        const options = convertReaderOptions(rawOptions, 'First parameter');\n        if (options.mode === undefined) {\n            return AcquireReadableStreamDefaultReader(this);\n        }\n        return AcquireReadableStreamBYOBReader(this);\n    }\n    pipeThrough(rawTransform, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('pipeThrough');\n        }\n        assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n        const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n        const options = convertPipeOptions(rawOptions, 'Second parameter');\n        if (IsReadableStreamLocked(this)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n        }\n        if (IsWritableStreamLocked(transform.writable)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n        }\n        const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        setPromiseIsHandledToTrue(promise);\n        return transform.readable;\n    }\n    pipeTo(destination, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n        }\n        if (destination === undefined) {\n            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n        }\n        if (!IsWritableStream(destination)) {\n            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n        }\n        let options;\n        try {\n            options = convertPipeOptions(rawOptions, 'Second parameter');\n        }\n        catch (e) {\n            return promiseRejectedWith(e);\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n        }\n        if (IsWritableStreamLocked(destination)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n        }\n        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n    }\n    /**\n     * Tees this readable stream, returning a two-element array containing the two resulting branches as\n     * new {@link ReadableStream} instances.\n     *\n     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n     * propagated to the stream's underlying source.\n     *\n     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n     * this could allow interference between the two branches.\n     */\n    tee() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('tee');\n        }\n        const branches = ReadableStreamTee(this);\n        return CreateArrayFromList(branches);\n    }\n    values(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('values');\n        }\n        const options = convertIteratorOptions(rawOptions, 'First parameter');\n        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n    }\n}\nObject.defineProperties(ReadableStream.prototype, {\n    cancel: { enumerable: true },\n    getReader: { enumerable: true },\n    pipeThrough: { enumerable: true },\n    pipeTo: { enumerable: true },\n    tee: { enumerable: true },\n    values: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStream',\n        configurable: true\n    });\n}\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n        value: ReadableStream.prototype.values,\n        writable: true,\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStream.\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n    return stream;\n}\nfunction InitializeReadableStream(stream) {\n    stream._state = 'readable';\n    stream._reader = undefined;\n    stream._storedError = undefined;\n    stream._disturbed = false;\n}\nfunction IsReadableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n        return false;\n    }\n    return x instanceof ReadableStream;\n}\nfunction IsReadableStreamLocked(stream) {\n    if (stream._reader === undefined) {\n        return false;\n    }\n    return true;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamCancel(stream, reason) {\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    ReadableStreamClose(stream);\n    const reader = stream._reader;\n    if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._closeSteps(undefined);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n    return transformPromiseWith(sourceCancelPromise, noop);\n}\nfunction ReadableStreamClose(stream) {\n    stream._state = 'closed';\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseResolve(reader);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._closeSteps();\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n}\nfunction ReadableStreamError(stream, e) {\n    stream._state = 'errored';\n    stream._storedError = e;\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseReject(reader, e);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._errorSteps(e);\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    else {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._errorSteps(e);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n}\n// Helper functions for the ReadableStream.\nfunction streamBrandCheckException$1(name) {\n    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\nfunction convertQueuingStrategyInit(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n    return {\n        highWaterMark: convertUnrestrictedDouble(highWaterMark)\n    };\n}\n\n// The size function must not have a prototype property nor be a constructor\nconst byteLengthSizeFunction = (chunk) => {\n    return chunk.byteLength;\n};\nObject.defineProperty(byteLengthSizeFunction, 'name', {\n    value: 'size',\n    configurable: true\n});\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nclass ByteLengthQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('highWaterMark');\n        }\n        return this._byteLengthQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by returning the value of its `byteLength` property.\n     */\n    get size() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('size');\n        }\n        return byteLengthSizeFunction;\n    }\n}\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ByteLengthQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the ByteLengthQueuingStrategy.\nfunction byteLengthBrandCheckException(name) {\n    return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\nfunction IsByteLengthQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return x instanceof ByteLengthQueuingStrategy;\n}\n\n// The size function must not have a prototype property nor be a constructor\nconst countSizeFunction = () => {\n    return 1;\n};\nObject.defineProperty(countSizeFunction, 'name', {\n    value: 'size',\n    configurable: true\n});\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nclass CountQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('highWaterMark');\n        }\n        return this._countQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by always returning 1.\n     * This ensures that the total queue size is a count of the number of chunks in the queue.\n     */\n    get size() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('size');\n        }\n        return countSizeFunction;\n    }\n}\nObject.defineProperties(CountQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'CountQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the CountQueuingStrategy.\nfunction countBrandCheckException(name) {\n    return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\nfunction IsCountQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return x instanceof CountQueuingStrategy;\n}\n\nfunction convertTransformer(original, context) {\n    assertDictionary(original, context);\n    const flush = original === null || original === void 0 ? void 0 : original.flush;\n    const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const transform = original === null || original === void 0 ? void 0 : original.transform;\n    const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n    return {\n        flush: flush === undefined ?\n            undefined :\n            convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n        readableType,\n        start: start === undefined ?\n            undefined :\n            convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n        transform: transform === undefined ?\n            undefined :\n            convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n        writableType\n    };\n}\nfunction convertTransformerFlushCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertTransformerStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertTransformerTransformCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\n// Class TransformStream\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nclass TransformStream {\n    constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n        if (rawTransformer === undefined) {\n            rawTransformer = null;\n        }\n        const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n        const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n        const transformer = convertTransformer(rawTransformer, 'First parameter');\n        if (transformer.readableType !== undefined) {\n            throw new RangeError('Invalid readableType specified');\n        }\n        if (transformer.writableType !== undefined) {\n            throw new RangeError('Invalid writableType specified');\n        }\n        const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n        const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n        const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n        const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n        let startPromise_resolve;\n        const startPromise = newPromise(resolve => {\n            startPromise_resolve = resolve;\n        });\n        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n        if (transformer.start !== undefined) {\n            startPromise_resolve(transformer.start(this._transformStreamController));\n        }\n        else {\n            startPromise_resolve(undefined);\n        }\n    }\n    /**\n     * The readable side of the transform stream.\n     */\n    get readable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('readable');\n        }\n        return this._readable;\n    }\n    /**\n     * The writable side of the transform stream.\n     */\n    get writable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('writable');\n        }\n        return this._writable;\n    }\n}\nObject.defineProperties(TransformStream.prototype, {\n    readable: { enumerable: true },\n    writable: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStream',\n        configurable: true\n    });\n}\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n    function startAlgorithm() {\n        return startPromise;\n    }\n    function writeAlgorithm(chunk) {\n        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    }\n    function abortAlgorithm(reason) {\n        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    }\n    function closeAlgorithm() {\n        return TransformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n    function pullAlgorithm() {\n        return TransformStreamDefaultSourcePullAlgorithm(stream);\n    }\n    function cancelAlgorithm(reason) {\n        TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n    stream._backpressure = undefined;\n    stream._backpressureChangePromise = undefined;\n    stream._backpressureChangePromise_resolve = undefined;\n    TransformStreamSetBackpressure(stream, true);\n    stream._transformStreamController = undefined;\n}\nfunction IsTransformStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n        return false;\n    }\n    return x instanceof TransformStream;\n}\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n    if (stream._backpressure) {\n        // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n        // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n        // _backpressure is set.\n        TransformStreamSetBackpressure(stream, false);\n    }\n}\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n    // Passes also when called during construction.\n    if (stream._backpressureChangePromise !== undefined) {\n        stream._backpressureChangePromise_resolve();\n    }\n    stream._backpressureChangePromise = newPromise(resolve => {\n        stream._backpressureChangePromise_resolve = resolve;\n    });\n    stream._backpressure = backpressure;\n}\n// Class TransformStreamDefaultController\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nclass TransformStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n     */\n    get desiredSize() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('desiredSize');\n        }\n        const readableController = this._controlledTransformStream._readable._readableStreamController;\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('enqueue');\n        }\n        TransformStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors both the readable side and the writable side of the controlled transform stream, making all future\n     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n     */\n    error(reason = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('error');\n        }\n        TransformStreamDefaultControllerError(this, reason);\n    }\n    /**\n     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n     * transformer only needs to consume a portion of the chunks written to the writable side.\n     */\n    terminate() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('terminate');\n        }\n        TransformStreamDefaultControllerTerminate(this);\n    }\n}\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    terminate: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStreamDefaultController',\n        configurable: true\n    });\n}\n// Transform Stream Default Controller Abstract Operations\nfunction IsTransformStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n        return false;\n    }\n    return x instanceof TransformStreamDefaultController;\n}\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n    controller._controlledTransformStream = stream;\n    stream._transformStreamController = controller;\n    controller._transformAlgorithm = transformAlgorithm;\n    controller._flushAlgorithm = flushAlgorithm;\n}\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n    const controller = Object.create(TransformStreamDefaultController.prototype);\n    let transformAlgorithm = (chunk) => {\n        try {\n            TransformStreamDefaultControllerEnqueue(controller, chunk);\n            return promiseResolvedWith(undefined);\n        }\n        catch (transformResultE) {\n            return promiseRejectedWith(transformResultE);\n        }\n    };\n    let flushAlgorithm = () => promiseResolvedWith(undefined);\n    if (transformer.transform !== undefined) {\n        transformAlgorithm = chunk => transformer.transform(chunk, controller);\n    }\n    if (transformer.flush !== undefined) {\n        flushAlgorithm = () => transformer.flush(controller);\n    }\n    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n    controller._transformAlgorithm = undefined;\n    controller._flushAlgorithm = undefined;\n}\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n        throw new TypeError('Readable side is not in a state that permits enqueue');\n    }\n    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n    // accept TransformStreamDefaultControllerEnqueue() calls.\n    try {\n        ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n    }\n    catch (e) {\n        // This happens when readableStrategy.size() throws.\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n        throw stream._readable._storedError;\n    }\n    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n    if (backpressure !== stream._backpressure) {\n        TransformStreamSetBackpressure(stream, true);\n    }\n}\nfunction TransformStreamDefaultControllerError(controller, e) {\n    TransformStreamError(controller._controlledTransformStream, e);\n}\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n    const transformPromise = controller._transformAlgorithm(chunk);\n    return transformPromiseWith(transformPromise, undefined, r => {\n        TransformStreamError(controller._controlledTransformStream, r);\n        throw r;\n    });\n}\nfunction TransformStreamDefaultControllerTerminate(controller) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    ReadableStreamDefaultControllerClose(readableController);\n    const error = new TypeError('TransformStream terminated');\n    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n// TransformStreamDefaultSink Algorithms\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n    const controller = stream._transformStreamController;\n    if (stream._backpressure) {\n        const backpressureChangePromise = stream._backpressureChangePromise;\n        return transformPromiseWith(backpressureChangePromise, () => {\n            const writable = stream._writable;\n            const state = writable._state;\n            if (state === 'erroring') {\n                throw writable._storedError;\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n    // errored.\n    TransformStreamError(stream, reason);\n    return promiseResolvedWith(undefined);\n}\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n    const readable = stream._readable;\n    const controller = stream._transformStreamController;\n    const flushPromise = controller._flushAlgorithm();\n    TransformStreamDefaultControllerClearAlgorithms(controller);\n    // Return a promise that is fulfilled with undefined on success.\n    return transformPromiseWith(flushPromise, () => {\n        if (readable._state === 'errored') {\n            throw readable._storedError;\n        }\n        ReadableStreamDefaultControllerClose(readable._readableStreamController);\n    }, r => {\n        TransformStreamError(stream, r);\n        throw readable._storedError;\n    });\n}\n// TransformStreamDefaultSource Algorithms\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n    // Invariant. Enforced by the promises returned by start() and pull().\n    TransformStreamSetBackpressure(stream, false);\n    // Prevent the next pull() call until there is backpressure.\n    return stream._backpressureChangePromise;\n}\n// Helper functions for the TransformStreamDefaultController.\nfunction defaultControllerBrandCheckException(name) {\n    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n// Helper functions for the TransformStream.\nfunction streamBrandCheckException(name) {\n    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n\nexport { ByteLengthQueuingStrategy, CountQueuingStrategy, ReadableByteStreamController, ReadableStream, ReadableStreamBYOBReader, ReadableStreamBYOBRequest, ReadableStreamDefaultController, ReadableStreamDefaultReader, TransformStream, TransformStreamDefaultController, WritableStream, WritableStreamDefaultController, WritableStreamDefaultWriter };\n//# sourceMappingURL=ponyfill.es2018.mjs.map\n"],"names":[],"mappings":"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"}